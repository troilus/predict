<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>ğŸŒ</title>
    <style>

  body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      min-height: 100vh;
      background-color: #f4f4f4;
      position: relative;
  }


      @media (prefers-color-scheme: dark) {
    body {
            background-color: #2c2c2c;

    };

}


#progress-bar-container {
    width: 100%;
    height: 8px;
    background-color: #e0e0e0; /* èƒŒæ™¯è‰² */
    position: relative;
    /* margin: 10px 0; ä¸ºå…ƒç´ ä¹‹é—´ç•™å‡ºé—´è· */
}

#progress-bar {
    height: 100%;
    width: 0%; /* åˆå§‹å®½åº¦ä¸º 0 */
    background-color: #76c7c0; /* è¿›åº¦æ¡é¢œè‰² */
    transition: width 0.5s ease; /* å¹³æ»‘åŠ¨ç”»æ•ˆæœ */
}



#download-link {
  display: none;
  text-decoration: none;
  color: black;
}


                    #made {
    margin-top: 20px; /* Increases the space above the element */
    font-size: 14px;  /* Optional: Adjust font size */
}


  #info-bar {
      width: 100%;
      background-color: #333;
      color: white;
      padding: 10px;
      text-align: center;
      font-size: 14px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
  }

  #canvas-container {
      position: relative;
      width: 300px;
      height: 300px;
      margin: 20px 0;
  }

#trajectory-canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 2;
            transform-origin: center;
            transform: rotate(0deg);

        }
  .compass {
      position: relative;
      width: 300px;
      height: 300px;
      margin: auto;
  }

        .compass-circle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(0deg);
            width: 100%;
            height: 100%;
            z-index: 1;
        }

.arrow {
    position: absolute;
    width: 0;              /* å®½åº¦è®¾ä¸º 0 */
    height: 0;             /* é«˜åº¦è®¾ä¸º 0 */
    top: -5px;            /* æ ¹æ®éœ€è¦è°ƒæ•´å‚ç›´ä½ç½® */
    left: 50%;             /* æ°´å¹³å±…ä¸­ */
    transform: translateX(-50%);
    border-left: 7px solid transparent; /* å·¦ä¾§é€æ˜ */
    border-right: 7px solid transparent; /* å³ä¾§é€æ˜ */
    border-top: 15px solid red;       /* ä¸‹è¾¹æ¡†ä¸ºçº¢è‰²ï¼Œå½¢æˆä¸‰è§’å½¢ */
    z-index: 3;            /* ä¿æŒåœ¨æœ€å‰é¢ */
}




          #satorbitpoint {
            position: absolute;
            top: 0;
            left: 0;
            transform: rotate(0deg);
            width: 100%;
            height: 100%;
            z-index: 1;
        }






  .start-btn {

  }


/* Basic styling for the popup */
#popup {
  position: fixed;
  top: 15%;
  left: 0;
  right: 0;
  bottom: 0;
  display: none; /* åˆå§‹éšè— */
  justify-content: center;
  align-items: center;
              z-index: 4;
}

#popup .popup-content {
  position: relative;
  padding: 20px;
  max-width: 600px;
  max-height: 80%;
  overflow-y: auto;
  background-color: white;
  border-radius: 10px;
}

#close-btn {
  position: absolute;
  top: 10px;
  right: 10px;
  cursor: pointer;
  font-size: 20px;
  font-weight: bold;
}

#satellite-feqinfo {
  max-height: 400px; /* è®¾å®šæœ€å¤§é«˜åº¦ */
  overflow-y: auto;  /* è¶…å‡ºæ—¶å‡ºç°å‚ç›´æ»šåŠ¨æ¡ */
}


</style>


<body>

    <div id="info-bar">
        <p id="satellite-name"></p>
        <p id="satellite-info"></p>
        <p id="pass-info"></p>
        <p id="time-info"></p>
    </div>
<div id="progress-bar-container">
    <div id="progress-bar"></div>
</div>
<div id="canvas-container">
    <canvas id="trajectory-canvas" width="300" height="300"></canvas>
    <div class="compass">
        <canvas class="compass-circle" id="compass-background" width="300" height="300"></canvas>
        <div class="arrow"></div>
    </div>


    <div id="elevation-bar" style="position: absolute; left: -25px; top: 0; height: 300px; width: 20px; background-color: #ddd; border: 0px solid #999; border-radius: 3px;">
    <div id="satellite-elevation" style="position: absolute; left: 1px; width: 18px; height: 18px; background-color: #e17822; border-radius: 50%;"></div>
    <div id="arrow-elevation" style="position: absolute; left: 2px; width: 16px; height: 16px; background-color: #186548; border-radius: 50%;"></div>


</div>

    <canvas id="satorbitpoint" width="300" height="300"></canvas>


</div>
    <button class="info-btn">å«æ˜Ÿé¢‘ç‡ä¿¡æ¯</button>
<div id="popup" class="popup">
  <div class="popup-content">
    <button id="close-btn" class="close-btn">Ã—</button>
    <div id="satellite-feqinfo"></div>
  </div>
</div>

    <div>
      <!-- Record button -->
      <button id="record-btn">å¼€å§‹å½•éŸ³</button>
      <button id="download-btn"  style="display: none;">ä¸‹è½½éŸ³é¢‘</button>
    </div>


    <button class="start-btn">iOSè®¾å¤‡ä¼ æ„Ÿå™¨æˆæƒ</button>
</body>




    <script src="satellite.js"></script>

  <script>
    const compassBackground = document.getElementById('compass-background');
    const compassCtx = compassBackground.getContext('2d');
    const compassCircle = document.querySelector(".compass-circle");

    const myPoint = document.querySelector(".my-point");
    const startBtn = document.querySelector(".start-btn");
    const isIOS =
      navigator.userAgent.match(/(iPod|iPhone|iPad)/) &&
      navigator.userAgent.match(/AppleWebKit/);

      const satpointCtx = document.getElementById('satorbitpoint').getContext('2d');





    function init() {
        startBtn.addEventListener("click", startCompass);
      //navigator.geolocation.getCurrentPosition(locationHandler);

      if (!isIOS) {
        window.addEventListener("deviceorientationabsolute", handler, true);
      }
    }

        // è®¾ç½®é»˜è®¤è¯­è¨€
        let currentLang = 'zh';

window.onload = function () {
    currentLang = localStorage.getItem('lang')
    const urlParams = new URLSearchParams(window.location.search);
    const index = urlParams.get('index');
    // è·å– localStorage ä¸­ä¿å­˜çš„å«æ˜Ÿæ•°æ®
    const satelliteData = JSON.parse(localStorage.getItem('selectedorbit'));
    const selectedPass = satelliteData[index - 1];  // ç´¢å¼•ä» 1 å¼€å§‹ï¼Œæ•°ç»„ä» 0 å¼€å§‹
    const trajectoryCtx = document.getElementById('trajectory-canvas').getContext('2d');

    let intervalId=-1; // å­˜å‚¨å®šæ—¶å™¨ID


    // ç»˜åˆ¶ç½—ç›˜èƒŒæ™¯
    drawCompassBackground(compassCtx);



    // æ˜¾ç¤ºå«æ˜Ÿä¿¡æ¯
    const satelliteName = localStorage.getItem('selectedSatelliteName');
    const satelliteTLE1 = localStorage.getItem('selectedSatelliteTLE1');
    const satelliteTLE2 = localStorage.getItem('selectedSatelliteTLE2');

    if (satelliteName && satelliteTLE1 && satelliteTLE2) {
        const satrec = satellite.twoline2satrec(satelliteTLE1, satelliteTLE2);

        const observerGd = {
            latitude: satellite.degreesToRadians(parseFloat(localStorage.getItem('latitude'))),
            longitude: satellite.degreesToRadians(parseFloat(localStorage.getItem('longitude'))),
            height: 0

        };



// è·å–å½“å‰æ—¶é—´
const currentTime = new Date();

// å°† selectedPass.entryTime å’Œ selectedPass.exitTime è½¬æ¢ä¸º Date å¯¹è±¡
const entryTime = new Date(selectedPass.entryTime);
const exitTime = new Date(selectedPass.exitTime);

if (currentLang == 'zh') {
// æ ¼å¼åŒ–æ—¶é—´
const formattedEntryTime = entryTime.toLocaleString('zh-CN', {
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
});

const formattedExitTime = exitTime.toLocaleString('zh-CN', {
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
});


document.getElementById('satellite-name').textContent = `${selectedPass.satelliteName} `;
document.getElementById('satellite-info').textContent = `å½“å‰æ–¹ä½ï¼šÂ° å½“å‰ä»°è§’ï¼šÂ° é¢„æµ‹æœ€é«˜ä»°è§’ï¼š${selectedPass.highestElevation}Â° `;
document.getElementById('pass-info').textContent = `å¼€å§‹ï¼š${formattedEntryTime} ${selectedPass.entryAzimuth}Â° | ç»“æŸï¼š${formattedExitTime} ${selectedPass.exitAzimuth}Â°`;
document.getElementById('time-info').textContent = "å½“å‰æ—¶é—´ï¼š";



    const satelliteElevation = document.getElementById('satellite-elevation');
        satelliteElevation.style.display = 'none';


     // ç»˜åˆ¶å«æ˜Ÿè¿‡å¢ƒè½¨è¿¹
    trajectoryPoints=drawTrajectory(trajectoryCtx, selectedPass, satrec, observerGd);


        setInterval(() => {
            const now = new Date();
            const positionAndVelocity = satellite.propagate(satrec, now);
            const gmst = satellite.gstime(now);

            const positionEci = positionAndVelocity.position;
            const lookAngles = satellite.ecfToLookAngles(
                observerGd,
                satellite.eciToEcf(positionEci, gmst)
            );

            const elevationdg =satellite.radiansToDegrees(lookAngles.elevation).toFixed(2);
            const azimuthdg = satellite.radiansToDegrees(lookAngles.azimuth).toFixed(2);
            const distance = satellite.eciToGeodetic(positionEci).height.toFixed(2);
            const height = positionEci.z.toFixed(2);


            document.getElementById('satellite-name').textContent = `${selectedPass.satelliteName} `;
            document.getElementById('satellite-info').textContent = `å½“å‰æ–¹ä½ï¼š${azimuthdg}Â° å½“å‰ä»°è§’ï¼š${elevationdg}Â° é¢„æµ‹æœ€é«˜ä»°è§’ï¼š${selectedPass.highestElevation}Â° `;
            document.getElementById('pass-info').textContent = `å¼€å§‹ï¼š${formattedEntryTime} ${selectedPass.entryAzimuth}Â° | ç»“æŸï¼š${formattedExitTime} ${selectedPass.exitAzimuth}Â°`;

const formattedTime = now.toLocaleString('zh-CN', {
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
});

// åˆ¤æ–­æ—¶é—´çŠ¶æ€å¹¶è®¾ç½®æ˜¾ç¤ºä¿¡æ¯
let timeInfo = `å½“å‰æ—¶é—´ï¼š${formattedTime}`;

if (now >= entryTime && now <= exitTime) {
    // å¦‚æœå½“å‰æ—¶é—´åœ¨ entryTime å’Œ exitTime ä¹‹é—´ï¼Œè®¡ç®—è·ç¦»ç»“æŸæ—¶é—´çš„å‰©ä½™æ—¶é—´
    const timeRemaining = exitTime - now;
    const hours = Math.floor(timeRemaining / (1000 * 60 * 60));
    const minutes = Math.floor((timeRemaining % (1000 * 60 * 60)) / (1000 * 60));
    const seconds = Math.floor((timeRemaining % (1000 * 60)) / 1000);
    timeInfo += `ï¼Œè·ç¦»ç»“æŸï¼š${hours}h ${minutes}m ${seconds}s`;
        updateSatellitePosition(satpointCtx, trajectoryPoints);
} else if (now < entryTime) {
    // å¦‚æœå½“å‰æ—¶é—´åœ¨ entryTime ä¹‹å‰ï¼Œè®¡ç®—è·ç¦»å¼€å§‹æ—¶é—´çš„å‰©ä½™æ—¶é—´
    const timeRemaining = entryTime - now;
    const hours = Math.floor(timeRemaining / (1000 * 60 * 60));
    const minutes = Math.floor((timeRemaining % (1000 * 60 * 60)) / (1000 * 60));
    const seconds = Math.floor((timeRemaining % (1000 * 60)) / 1000);
    timeInfo += `ï¼Œè·ç¦»å¼€å§‹ï¼š${hours}h ${minutes}m ${seconds}s`;
    const satelliteElevation = document.getElementById('satellite-elevation');
        satelliteElevation.style.display = 'none';
        satpointCtx.clearRect(0, 0, 300, 300);

} else if (now > exitTime) {
    // å¦‚æœå½“å‰æ—¶é—´åœ¨ exitTime ä¹‹åï¼Œåªæ˜¾ç¤ºå½“å‰æ—¶é—´
    timeInfo = `å½“å‰æ—¶é—´ï¼š${formattedTime}`;
    const satelliteElevation = document.getElementById('satellite-elevation');
        satelliteElevation.style.display = 'none';
        satpointCtx.clearRect(0, 0, 300, 300);
}

// æ›´æ–°æ˜¾ç¤ºå†…å®¹
document.getElementById('time-info').textContent = timeInfo;
       updateProgressBar(entryTime, exitTime, now);


        }, 1000);
        } else {

// æ ¼å¼åŒ–æ—¶é—´

// è·å–æŒ‰é’®å…ƒç´ 
const button = document.querySelector('.start-btn');

// ä¿®æ”¹æŒ‰é’®æ–‡å­—
button.textContent = 'iOS Device Sensor Authorization';


const formattedEntryTime = entryTime.toLocaleString('zh-CN', {
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
});

const formattedExitTime = exitTime.toLocaleString('zh-CN', {
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
});




document.getElementById('satellite-name').textContent = `${selectedPass.satelliteName} `;
document.getElementById('satellite-info').textContent = `AzNow: Â° ElNow: Â° MaxElï¼š${selectedPass.highestElevation}Â° `;
document.getElementById('pass-info').textContent = `Start: ${formattedEntryTime} ${selectedPass.entryAzimuth}Â° | End: ${formattedExitTime} ${selectedPass.exitAzimuth}Â°`;
document.getElementById('time-info').textContent = "";








    const satelliteElevation = document.getElementById('satellite-elevation');
        satelliteElevation.style.display = 'none';




     // ç»˜åˆ¶å«æ˜Ÿè¿‡å¢ƒè½¨è¿¹
    drawTrajectory(trajectoryCtx, selectedPass, satrec, observerGd);




        setInterval(() => {
            const now = new Date();
            const positionAndVelocity = satellite.propagate(satrec, now);
            const gmst = satellite.gstime(now);

            const positionEci = positionAndVelocity.position;
            const lookAngles = satellite.ecfToLookAngles(
                observerGd,
                satellite.eciToEcf(positionEci, gmst)
            );

            const elevationdg =satellite.radiansToDegrees(lookAngles.elevation).toFixed(2);
            const azimuthdg = satellite.radiansToDegrees(lookAngles.azimuth).toFixed(2);
            const distance = satellite.eciToGeodetic(positionEci).height.toFixed(2);
            const height = positionEci.z.toFixed(2);


            document.getElementById('satellite-name').textContent = `${selectedPass.satelliteName} `;
            document.getElementById('satellite-info').textContent = `AzNow: ${azimuthdg}Â° ElNow: ${elevationdg}Â° MaxEl: ${selectedPass.highestElevation}Â° `;
            document.getElementById('pass-info').textContent = `Start: ${formattedEntryTime} ${selectedPass.entryAzimuth}Â° | End: ${formattedExitTime} ${selectedPass.exitAzimuth}Â°`;

const formattedTime = now.toLocaleString('zh-CN', {
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
});

// åˆ¤æ–­æ—¶é—´çŠ¶æ€å¹¶è®¾ç½®æ˜¾ç¤ºä¿¡æ¯
let timeInfo = `${formattedTime}`;

if (now >= entryTime && now <= exitTime) {
    // å¦‚æœå½“å‰æ—¶é—´åœ¨ entryTime å’Œ exitTime ä¹‹é—´ï¼Œè®¡ç®—è·ç¦»ç»“æŸæ—¶é—´çš„å‰©ä½™æ—¶é—´
    const timeRemaining = exitTime - now;
    const hours = Math.floor(timeRemaining / (1000 * 60 * 60));
    const minutes = Math.floor((timeRemaining % (1000 * 60 * 60)) / (1000 * 60));
    const seconds = Math.floor((timeRemaining % (1000 * 60)) / 1000);
    timeInfo += `ï¼ŒEnd in: ${hours}h ${minutes}m ${seconds}s`;

        updateSatellitePosition(satpointCtx, trajectoryPoints);

} else if (now < entryTime) {
    // å¦‚æœå½“å‰æ—¶é—´åœ¨ entryTime ä¹‹å‰ï¼Œè®¡ç®—è·ç¦»å¼€å§‹æ—¶é—´çš„å‰©ä½™æ—¶é—´
    const timeRemaining = entryTime - now;
    const hours = Math.floor(timeRemaining / (1000 * 60 * 60));
    const minutes = Math.floor((timeRemaining % (1000 * 60 * 60)) / (1000 * 60));
    const seconds = Math.floor((timeRemaining % (1000 * 60)) / 1000);
    timeInfo += `ï¼ŒStart in: ${hours}h ${minutes}m ${seconds}s`;
    const satelliteElevation = document.getElementById('satellite-elevation');
        satelliteElevation.style.display = 'none';


                  satpointCtx.clearRect(0, 0, 300, 300);
} else if (now > exitTime) {
    // å¦‚æœå½“å‰æ—¶é—´åœ¨ exitTime ä¹‹åï¼Œåªæ˜¾ç¤ºå½“å‰æ—¶é—´
    timeInfo = `${formattedTime}`;
    const satelliteElevation = document.getElementById('satellite-elevation');
        satelliteElevation.style.display = 'none';


                  satpointCtx.clearRect(0, 0, 300, 300);
}

// æ›´æ–°æ˜¾ç¤ºå†…å®¹
document.getElementById('time-info').textContent = timeInfo;



        }, 1000);
        }
    }
};





function drawCompassBackground(ctx) {
            const centerX = 150;
            const centerY = 150;
            const radius = 140;

            // Draw outer circle
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.stroke();


    // Draw center point
    ctx.beginPath();
    ctx.arc(centerX, centerY, 3, 0, 2 * Math.PI); // Small circle with radius 3
    ctx.fillStyle = 'black'; // Color of the point
    ctx.fill();


            // Draw concentric circles for 30Â° and 60Â° elevation
            const circleAngles = [30, 60];
            circleAngles.forEach((elevation) => {
                const circleRadius = (radius * (90 - elevation)) / 90;
                ctx.beginPath();
                ctx.arc(centerX, centerY, circleRadius, 0, 2 * Math.PI);
                ctx.strokeStyle = 'gray';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
            });
            ctx.setLineDash([]); // Reset dash style

            // Draw cardinal directions
            const directions = [ '','N', '', 'S'];
            directions.forEach((dir, index) => {
                const angle = (index * 90) * (Math.PI / 180);
                const x = centerX + (radius - 40) * Math.cos(angle);
                const y = centerY - (radius - 20) * Math.sin(angle);
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(dir, x, y);
            });

            // Draw intermediate tick marks
            for (let i = 0; i < 360; i += 10) {
                const angle = (i - 90) * (Math.PI / 180);
                const x1 = centerX + radius * Math.cos(angle);
                const y1 = centerY - radius * Math.sin(angle);
                const x2 = centerX + (radius - 10) * Math.cos(angle);
                const y2 = centerY - (radius - 10) * Math.sin(angle);
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.strokeStyle = 'gray';
                ctx.lineWidth = i % 90 === 0 ? 2 : 1; // Thicker for cardinal directions
                ctx.stroke();
            }
        }




function getRadiusForElevation(elevation, radius) {
    if (elevation <= 30) return radius - (radius * 0.25) * (elevation / 30);
    if (elevation <= 60) return radius * 0.75 - (radius * 0.25) * ((elevation - 30) / 30);
    return radius * 0.5 - (radius * 0.25) * ((elevation - 60) / 30);
}

// ç»˜åˆ¶è½¨è¿¹æ›²çº¿
function drawTrajectory(ctx, selectedPass, satrec, observerGd) {


    const startTime = new Date(selectedPass.entryTime);
    const endTime = new Date(selectedPass.exitTime);

   const steps = 1000;
    const timeStep = (endTime - startTime) / steps;


    const trajectoryPoints = [];
    
    // Loop through selectedPass (pass times or observations) and calculate satellite position
    for (let i = 0; i <= steps; i++) {
        const passTime = new Date(startTime.getTime() + i * timeStep);


        // Get the satellite position at this pass time
        const positionAndVelocity = satellite.propagate(satrec, passTime);
        const gmst = satellite.gstime(passTime);
        const positionEci = positionAndVelocity.position;

        // Get the look angles (elevation and azimuth) at this time
        const lookAngles = satellite.ecfToLookAngles(
            observerGd,
            satellite.eciToEcf(positionEci, gmst)
        );

        const elevation = satellite.radiansToDegrees(lookAngles.elevation);
        const azimuth = satellite.radiansToDegrees(lookAngles.azimuth);

        // Only consider valid look angles (elevation between 0 and 90 degrees)
        if (elevation > 0 && elevation <= 90) {
            const centerX = 150;
            const centerY = 150;
            const radius = 140;

            // Map elevation to a radius on the compass
            const satelliteRadius = radius * (90 - elevation) / 90;

            // Calculate the x, y coordinates of the satellite on the compass
            const satelliteX = centerX + satelliteRadius * Math.cos((90 - azimuth) * (Math.PI / 180));
            const satelliteY = centerY - satelliteRadius * Math.sin((90 - azimuth) * (Math.PI / 180));

            // Store the trajectory points
            trajectoryPoints.push({ x: satelliteX, y: satelliteY, time: passTime, eleva:elevation});
        }
    } 

    // Draw the trajectory line connecting all points
    ctx.beginPath();
    ctx.moveTo(trajectoryPoints[0].x, trajectoryPoints[0].y);

    for (let i = 1; i < trajectoryPoints.length; i++) {
        ctx.lineTo(trajectoryPoints[i].x, trajectoryPoints[i].y);

    }
    ctx.strokeStyle = 'blue'; // Trajectory line color
    ctx.lineWidth = 2;
    ctx.stroke();


    // ç»˜åˆ¶è°ƒè¯•ç‚¹
    //drawDebugPoint(ctx, trajectoryPoints[0].x, trajectoryPoints[0].y, 'green', 'Start');
    //drawDebugPoint(ctx, trajectoryPoints[(trajectoryPoints.length+1)/2].x, trajectoryPoints[(trajectoryPoints.length+1)/2].y, 'red', 'El'); 
    //drawDebugPoint(ctx, trajectoryPoints[trajectoryPoints.length-1].x, trajectoryPoints[trajectoryPoints.length-1].y, 'green', '');

/*if (elevation < 0) {
        // å½“ä»°è§’å°äºæˆ–ç­‰äº0æ—¶ï¼Œç¡®ä¿å«æ˜Ÿç‚¹ä¸æ˜¾ç¤º
        ctx.clearRect(0, 0, 300, 300); // æ¸…ç©ºå›¾å±‚ï¼Œé¿å…æ˜¾ç¤ºå«æ˜Ÿç‚¹
    }*/


 // Function to draw arrows
    function drawArrow(x1, y1, x2, y2, color) {
        const headLength = 10; // Length of the arrowhead
        const dx = x2 - x1;
        const dy = y2 - y1;
        const angle = Math.atan2(dy, dx);

        // Draw line
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.stroke();

        // Draw arrowhead
        ctx.beginPath();
        ctx.moveTo(x2, y2);
        ctx.lineTo(x2 - headLength * Math.cos(angle - Math.PI / 6), y2 - headLength * Math.sin(angle - Math.PI / 6));
        ctx.lineTo(x2 - headLength * Math.cos(angle + Math.PI / 6), y2 - headLength * Math.sin(angle + Math.PI / 6));
        ctx.lineTo(x2, y2);
        ctx.fillStyle = color;
        ctx.fill();
    }

    // Draw arrows at 1/3 and 2/3 of the trajectory
    const oneThirdIndex = Math.floor(trajectoryPoints.length   / 2);
    //const twoThirdIndex = Math.floor(trajectoryPoints.length * 2 / 3);

    if (trajectoryPoints.length > 2) {
        const arrow1Start = trajectoryPoints[oneThirdIndex - 1];
        const arrow1End = trajectoryPoints[oneThirdIndex];
        drawArrow(arrow1Start.x, arrow1Start.y, arrow1End.x, arrow1End.y, 'red');

        /*const arrow2Start = trajectoryPoints[twoThirdIndex - 1];
        const arrow2End = trajectoryPoints[twoThirdIndex];
        drawArrow(arrow2Start.x, arrow2Start.y, arrow2End.x, arrow2End.y, 'red');*/
    }



    return trajectoryPoints;
}


// è°ƒè¯•å‡½æ•°ï¼šç»˜åˆ¶è½¨è¿¹ç‚¹ä½ç½®
function drawDebugPoint(ctx, x, y, color, label) {
    ctx.beginPath();
    ctx.arc(x, y, 3, 0, 2 * Math.PI);
    ctx.fillStyle = color;
    ctx.fill();
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(label, x+5, y - 5);
}

// ç”Ÿæˆè½¨è¿¹ä¸Šçš„ç‚¹æ•°ç»„
/*function generateTrajectoryPoints(entryX, entryY, highestX, highestY, exitX, exitY, steps = 100) {
    const points = [];
    for (let t = 0; t <= 1; t += 1 / steps) {
        const x = Math.pow(1 - t, 2) * entryX +
                  2 * (1 - t) * t * highestX +
                  Math.pow(t, 2) * exitX;
        const y = Math.pow(1 - t, 2) * entryY +
                  2 * (1 - t) * t * highestY +
                  Math.pow(t, 2) * exitY;
        points.push({ x, y });
    }
    return points;
}*/


// æŠ•å°„çº¢ç‚¹åˆ°æ›²çº¿çš„æœ€è¿‘ç‚¹
/*function projectPointToCurve(x, y, trajectoryPoints) {
    let minDistance = Infinity;
    let closestPoint = { x: 0, y: 0 };

    trajectoryPoints.forEach(point => {
        const distance = Math.hypot(point.x - x, point.y - y);
        if (distance < minDistance) {
            minDistance = distance;
            closestPoint = point;
        }
    });

    return closestPoint;
}*/

// æ›´æ–°å«æ˜Ÿä½ç½®å¹¶ç»˜åˆ¶å®æ—¶è½¨è¿¹
function updateSatellitePosition(ctx, trajectoryPoints) { 
    const now = new Date();

        // æ‰¾åˆ°å½“å‰æ—¶é—´æœ€è¿‘çš„è½¨è¿¹ç‚¹
    let closestPoint = trajectoryPoints[0];

    let minTimeDiff = Math.abs(now - closestPoint.time);
        for (let i = 1; i < trajectoryPoints.length; i++) {
        const timeDiff = Math.abs(now - trajectoryPoints[i].time);
        if (timeDiff < minTimeDiff) {
            closestPoint = trajectoryPoints[i];
            minTimeDiff = timeDiff;

        }
    }


                // æ˜¾ç¤ºå«æ˜Ÿçš„ä»°è§’
    const elevationBar = document.getElementById('elevation-bar');
    const satelliteElevation = document.getElementById('satellite-elevation');
    satelliteElevation.style.display = 'block';  // æˆ– 'inline' æ ¹æ®éœ€è¦é€‰æ‹©

    const barHeight = elevationBar.offsetHeight-9;
// éœ€è¦ç¡®ä¿ elevation åœ¨ 0 åˆ° 90 ä¹‹é—´


if (closestPoint.eleva > 0 && closestPoint.eleva <= 90) {



    // æ˜ å°„å«æ˜Ÿçš„ä»°è§’åˆ°ä»°è§’æ¡çš„ä½ç½® (0 - 90åº¦ -> 0 - barHeight)
    const satelliteElevationDistance = (90 - closestPoint.eleva) / 90 * barHeight;

    // æ›´æ–°è“è‰²ç‚¹çš„ä½ç½®
    satelliteElevation.style.top = `${satelliteElevationDistance  - satelliteElevation.offsetHeight / 2}px`;


} else {
    // å¦‚æœ elevation ä¸åœ¨æœ‰æ•ˆèŒƒå›´å†…ï¼Œå¯ä»¥é€‰æ‹©ä¸æ˜¾ç¤ºæˆ–è€…æ˜¾ç¤ºä¸€ä¸ªé»˜è®¤å€¼
    satelliteElevation.style.display = 'none';
}

    // æ¸…ç©ºå›¾å±‚ï¼Œé‡æ–°ç»˜åˆ¶å½“å‰å«æ˜Ÿç‚¹
ctx.clearRect(0, 0, 300, 300);

if (closestPoint.eleva > 0 && closestPoint.eleva <= 90) {

    const centerX = 150;
    const centerY = 150;

    // ç»˜åˆ¶å«æ˜Ÿå®æ—¶ä½ç½®
    ctx.beginPath();
    ctx.arc(closestPoint.x, closestPoint.y, 5, 0, 2 * Math.PI);
    ctx.fillStyle = 'blue';
    ctx.fill();

    // ç»˜åˆ¶ä¸­å¿ƒåˆ°å«æ˜Ÿçš„è¿çº¿
    ctx.beginPath();
    ctx.moveTo(centerX, centerY);
    ctx.lineTo(closestPoint.x, closestPoint.y);
    ctx.strokeStyle = 'blue';
    ctx.lineWidth = 1;
    ctx.stroke();


}else if (closestPoint.eleva < 0){

        ctx.clearRect(0, 0, 300, 300);


    }








    
}


    function startCompass() {
      if (isIOS) {
        DeviceOrientationEvent.requestPermission()
          .then((response) => {
            if (response === "granted") {
              window.addEventListener("deviceorientation", handler, true);
            } else {
              alert("has to be allowed!");
            }
          })
          .catch(() => alert("not supported"));
      }
    }


    function updateProgressBar(entryTime, exitTime, now) {
    const progressBar = document.getElementById('progress-bar');

    // è®¡ç®—å½“å‰æ—¶é—´åœ¨æ€»æ—¶é—´ä¸­çš„ç™¾åˆ†æ¯”
    const totalDuration = exitTime - entryTime;
    const elapsedTime = now - entryTime;
    const progressPercentage = Math.min(
        Math.max((elapsedTime / totalDuration) * 100, 0),
        100
    ); // ç¡®ä¿ç™¾åˆ†æ¯”åœ¨ 0-100 ä¹‹é—´

    // æ›´æ–°è¿›åº¦æ¡å®½åº¦
    progressBar.style.width = `${progressPercentage}%`;
}





function handler(e) {

    const compass = e.webkitCompassHeading || Math.abs(e.alpha - 360);

    // Define the center of the compass
    const centerX = 150;
    const centerY = 150;

    // Rotate compass circle
    compassCircle.style.transform = `translate(-50%, -50%) rotate(${-compass}deg)`;
    compassBackground.style.transform = `translate(-50%, -50%) rotate(${-compass}deg)`;

    // Rotate trajectory canvas
    const trajectoryCanvas = document.getElementById('trajectory-canvas');
    trajectoryCanvas.style.transformOrigin = 'center';
    trajectoryCanvas.style.transform = `rotate(${-compass}deg)`;


    // 
    const satorbitpointCanvas = document.getElementById('satorbitpoint');
    satorbitpointCanvas.style.transformOrigin = 'center';
    satorbitpointCanvas.style.transform = `rotate(${-compass}deg)`;


     // Handle arrow position based on beta
    const beta = e.beta;  // Get the beta value from the event
    const arrow = document.querySelector('.arrow');

    // Radius of the compass circle
    const radius = 140; 

    // Map beta value to distance: 
    // When beta = 0, distance = radius (edge)
    // When beta = 90, distance = 0 (center)
    const distance = (90 - beta) / 90 * radius;  // Inverse the scaling to match your requirement

    // Calculate the Y position based on beta (upward or downward movement)
    const arrowY = centerY-50;  // Adjust Y position to move the arrow vertically
    const arrowX = centerX;  // Keep the arrow horizontally centered

   /* // Update arrow position
    if ( arrowY >=10 && arrowY<=150){
    arrow.style.top = `${arrowY - 10}px`; // Adjust top to position the arrow

} else if (arrowY>150) {
arrow.style.top = `${arrowY - 140}px`; // Adjust top to position the arrow

}


*/
    // Control red point visibility based on compass angle

    // è·å–ä»°è§’æ¡å’Œé»„ç‚¹
const elevationBar = document.getElementById('elevation-bar');
const arrowElevation = document.getElementById('arrow-elevation');

// é«˜åº¦æ¡æ€»é•¿åº¦
const barHeight = elevationBar.offsetHeight-9;

// æ˜ å°„ beta (0 - 90) åˆ°ä»°è§’æ¡ (0 - barHeight)




if (beta > 90) {
    adjustedBeta = 90; // å¦‚æœ beta > 90ï¼Œå¼ºåˆ¶è®¾ä¸º 90
} else if (beta < 0) {
    adjustedBeta = 0; // å¦‚æœ beta < 90ï¼Œå¼ºåˆ¶è®¾ä¸º 0
} else {
    adjustedBeta = beta; // beta == 90 æ—¶ï¼Œä¿æŒä¸º 90
}

const elevationDistance = (90 - adjustedBeta) / 90 * barHeight;






// æ›´æ–°çº¢ç‚¹ä½ç½®

arrowElevation.style.top = `${elevationDistance - arrowElevation.offsetHeight / 2}px`;



}

    


  /*  let pointDegree;

    function locationHandler(position) {
      const { latitude, longitude } = position.coords;
      pointDegree = calcDegreeToPoint(latitude, longitude);

      if (pointDegree < 0) {
        pointDegree = pointDegree + 360;
      }
    }

 function calcDegreeToPoint(latitude, longitude) {
      // Qibla geolocation
      const point = {
        lat: 21.422487,
        lng: 39.826206
      };

      const phiK = (point.lat * Math.PI) / 180.0;
      const lambdaK = (point.lng * Math.PI) / 180.0;
      const phi = (latitude * Math.PI) / 180.0;
      const lambda = (longitude * Math.PI) / 180.0;
      const psi =
        (180.0 / Math.PI) *
        Math.atan2(
          Math.sin(lambdaK - lambda),
          Math.cos(phi) * Math.tan(phiK) -
            Math.sin(phi) * Math.cos(lambdaK - lambda)
        );
      return Math.round(psi);
    }
*/


        if (window.DeviceOrientationEvent) {
            window.addEventListener('deviceorientation', function (event) {
                /*var a = document.getElementById('alpha'),
                    b = document.getElementById('beta'),
                    g = document.getElementById('gamma'),*/

                    alpha = event.alpha,
                    beta = event.beta,
                    gamma = event.gamma;

                /*a.innerHTML = Math.round(alpha);
                b.innerHTML = Math.round(beta);
                g.innerHTML = Math.round(gamma);*/

                  // Update arrow and compass position
        handler(event);      



            }, false);
        } else {
            document.querySelector('body').innerHTML = 'ä½ çš„æµè§ˆå™¨ä¸æ”¯æŒé™€èºä»ª';
        }




//é¢‘ç‡è¡¨å¼€å§‹
document.addEventListener('DOMContentLoaded', function() {
  const infoButton = document.querySelector('.info-btn');
  const popup = document.getElementById('popup');
  const closeButton = document.getElementById('close-btn');
  const satelliteInfo = document.getElementById('satellite-feqinfo');
  
  // Authorization token (use the correct token here)
  const authorizationToken = '04dbc5423ace07e1caad69925c275a4d4d48d342';

  infoButton.addEventListener('click', function() {
    // Fetch the selected satellite NORAD catalog ID from localStorage
    const selectedSatelliteTLE2 = localStorage.getItem('selectedSatelliteTLE2');
    const selectedsat = localStorage.getItem('selectedSatelliteName');
    if (!selectedSatelliteTLE2) {
      alert('No satellite selected');
      return;
    }

    // Extract the NORAD catalog ID from TLE2 string (assuming it's the second part)
    const noradCatId = selectedSatelliteTLE2.split(' ')[1];

    // Check if we already have frequency information for this NORAD catalog ID in localStorage
    const storedData = localStorage.getItem('freqinfo');
    const freqInfo = storedData ? JSON.parse(storedData) : {};

    // Show loading text before fetching data
    satelliteInfo.innerHTML = '<p>Loading...</p>';

    // If we have data for this NORAD catalog ID, use it
    if (freqInfo[noradCatId]) {
      displayFrequencyData(freqInfo[noradCatId], selectedsat);
    } else {
      // Otherwise, fetch data from the API
      fetchSatelliteData(noradCatId, selectedsat);
    }

    // Show the popup
    popup.style.display = 'block';
  });

  // Close the popup when the close button is clicked
  closeButton.addEventListener('click', function() {
    popup.style.display = 'none';
  });

  // Close the popup if user clicks outside the popup content
  window.addEventListener('click', function(event) {
    if (event.target === popup) {
      popup.style.display = 'none';
    }
  });

  // Function to fetch data from the API
  function fetchSatelliteData(noradCatId, selectedsat) {
    const apiUrl = `https://c0rs.xanyi.eu.org/c0rs/?https://db.satnogs.org/api/transmitters/?alive=true&format=json&satellite__norad_cat_id=${noradCatId}&status=active`;

    fetch(apiUrl, {
      method: 'GET',
      headers: {
        'Accept': 'application/json',
        'Authorization': `Bearer ${authorizationToken}` // Adding the authorization header
      }
    })
    .then(response => response.json()) // Parse the JSON response
    .then(data => {
      if (data.length === 0) {
        satelliteInfo.innerHTML = '<p>No frequency information available.</p>';
      } else {
        // Add data to freqinfo with the corresponding noradCatId
        const freqInfo = JSON.parse(localStorage.getItem('freqinfo') || '{}');
        freqInfo[noradCatId] = data; // Store the data under the noradCatId

        // Store updated data back to localStorage
        localStorage.setItem('freqinfo', JSON.stringify(freqInfo));

        // Display the fetched data
        displayFrequencyData(data, selectedsat);
      }
    })
    .catch(error => {
      console.error('Error fetching satellite data:', error);
      satelliteInfo.innerHTML = '<p>Error fetching data.</p>';
    });
  }

  // Function to format frequency to MHz (e.g., 136650000 => 136.650 MHz)
  function formatFrequency(freq) {
    return freq ? (freq / 1000000).toFixed(3) + ' MHz' : 'N/A';
  }

  // Function to display frequency data in the popup
  function displayFrequencyData(data, selectedsat) {
    let content = `<h3>${selectedsat}</h3>`;
    data.forEach(item => {
      content += `
        <p><strong>Description:</strong> ${item.description}</p>
        <div style="display: flex; justify-content: space-between; align-items: center;">
          <p><strong>downlink:</strong> ${formatFrequency(item.downlink_low)}</p>
          <p><strong>uplink:</strong> ${formatFrequency(item.uplink_low)}</p>
        </div>
        <hr>
      `;
    });

    // Display the content in satelliteInfo
    satelliteInfo.innerHTML = content;
  }
});

//é¢‘ç‡è¡¨ç»“æŸ


//å½•éŸ³å¼€å§‹
document.addEventListener('DOMContentLoaded', function() {
  const recordBtn = document.getElementById('record-btn');

  const download = document.getElementById('download-btn');
  
  let isRecording = false;
  let mediaRecorder;
  let audioChunks = [];
  let audioBlob;
  let audioUrl;
  let audioFile;
    let fileSizeInMB = 0;

  // Function to handle recording button
  recordBtn.addEventListener('click', function() {
    if (isRecording) {
      // Stop recording
      mediaRecorder.stop();
      recordBtn.textContent = 'å¼€å§‹å½•éŸ³';
      downloadBtn.style.display = 'inline-block';  // Show the download button
    } else {
      // Start recording
      startRecording();
            // Clear previous recording data before starting a new recording
      audioChunks = [];
      fileSizeInMB = 0;  // Reset file size
      recordBtn.textContent = `ç»“æŸå½•éŸ³`;
      downloadBtn.style.display = 'none';  // Hide download button until recording ends
    }
    isRecording = !isRecording;
  });

  // Function to start recording
  function startRecording() {
    navigator.mediaDevices.getUserMedia({ audio: true })
      .then(function(stream) {
        mediaRecorder = new MediaRecorder(stream);
        mediaRecorder.start();

        mediaRecorder.ondataavailable = function(event) {
          audioChunks.push(event.data);
        };

        mediaRecorder.onstop = function() {
          audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
          audioUrl = URL.createObjectURL(audioBlob);
          audioFile = new File([audioBlob], `${getSatelliteName()}-${getCurrentTimestamp()}.wav`, { type: 'audio/wav' });




                    // Calculate the size of the recorded file in MB
          fileSizeInMB = audioBlob.size / (1024 * 1024);  // Size in MB

          // Update the download button text with the file size
          downloadBtn.textContent = `ä¸‹è½½éŸ³é¢‘ - ${fileSizeInMB.toFixed(2)}MB`;

          // Clear previous event listeners before adding a new one
          downloadBtn.removeEventListener('click', downloadAudio);

          // Bind a new event listener for downloading the audio file
          downloadBtn.addEventListener('click', downloadAudio);



        };
      })
      .catch(function(error) {
        console.error("Error accessing audio devices:", error);
      });
  }


    // ä¸‹è½½éŸ³é¢‘çš„å‡½æ•°
  function downloadAudio() {
    const link = document.createElement('a');
    link.href = audioUrl;
    link.download = audioFile.name;
    link.click();
  }



  // Function to get the satellite name (you can replace this logic with actual satellite name)
  function getSatelliteName() {
    return localStorage.getItem('selectedSatelliteName') || 'Satellite';
  }

  // Function to get the current timestamp
  function getCurrentTimestamp() {
    const now = new Date();
    return `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')} ${String(now.getHours()).padStart(2, '0')}_${String(now.getMinutes()).padStart(2, '0')}_${String(now.getSeconds()).padStart(2, '0')}`;
  }
});

//å½•éŸ³ç»“æŸ

    init();
  </script>


        <!-- alpha: <span id="alpha"></span><br/>
    beta: <span id="beta"></span><br/>
    gamma: <span id="gamma"></span><br/>-->

<div id="made">
  Made with â¤ by troilus.   <a href="https://github.com/troilus/predict" target="_blank" style="color: black;">Code</a> 
</div>

</html>
