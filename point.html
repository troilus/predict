<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/manifest.json">
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />

    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">


    <title>🌎ORBIT</title>
    <style>

  body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      min-height: 100vh;
      background-color: #f2f2f7;
      position: relative;
                  -webkit-font-smoothing: antialiased;
  }

#doppler-info {
    font-size: 12px;
    color: #000000;
}

.button-container {
    display: flex;
    gap: 10px;  /* 按钮之间的间距 */
}




          /* 默认情况下，链接颜色为黑色 */
  .link {
    color: #333 ;
    text-decoration: none;
  }


#progress-bar-container {
    width: 100%;
    height: 8px;
    background-color: #e0e0e0; /* 背景色 */
    position: relative;
    /* margin: 10px 0; 为元素之间留出间距 */
}

#progress-bar {
    height: 100%;
    width: 0%; /* 初始宽度为 0 */
    background-color: #76c7c0; /* 进度条颜色 */
    transition: width 0.5s ease; /* 平滑动画效果 */
}


#elapsed-time, #remaining-time {
    color: inherit; /* 继承父元素颜色 */
}
#download-link {
  display: none;
  text-decoration: none;
  color: black;
}


                    #made {
    margin-top: 20px; /* Increases the space above the element */
    font-size: 14px;  /* Optional: Adjust font size */
}


  #info-bar {
      width: 100%;
      background-color: #2e71d1;
      color: white;
      padding: 10px;
      text-align: center;
      font-size: 14px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
  }

  #canvas-container {
      position: relative;
      width: 300px;
      height: 300px;
      margin: 40px 0;
  }

#trajectory-canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 3;
            transform-origin: center;
            transform: rotate(0deg);

        }
  #trajectory-svg, .compass {
      position: absolute;
      top: 0;
      left: 0;
      width: 300px;
      height: 300px;
  }

  .compass {
      z-index: -1; /* 背景层 */
  }




  #satorbitpointsvg {
      z-index: 3; /* 轨迹层 */
  }
        .compass-circle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(0deg);
            width: 100%;
            height: 100%;
            z-index: -1;
        }

.arrow {
    position: absolute;
    width: 0;              /* 宽度设为 0 */
    height: 0;             /* 高度设为 0 */
    top: -5px;            /* 根据需要调整垂直位置 */
    left: 50%;             /* 水平居中 */
    transform: translateX(-50%);
    border-left: 7px solid transparent; /* 左侧透明 */
    border-right: 7px solid transparent; /* 右侧透明 */
    border-top: 15px solid red;       /* 下边框为红色，形成三角形 */
    z-index: 3;            /* 保持在最前面 */
}




          #satorbitpoint {
            position: absolute;
            top: 0;
            left: 0;
            transform: rotate(0deg);
            width: 100%;
            height: 100%;
            z-index: 4;
        }






 .info-btn, .record-btn, .download-btn {
        padding: 12px 20px;
    border: none;
    border-radius: 12px;
    background-color: #2e71d1;
    color: white;
    font-size: 12px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s;
    -webkit-tap-highlight-color: transparent;
    margin-top: 5px;  /* 上间距 */
        margin-bottom: 10px;  /* 上间距 */

  }


/* Basic styling for the popup */
#popup {
  position: fixed;
  top: 50%;  /* 定位在页面的垂直中间 */
  left: 50%; /* 定位在页面的水平中间 */
  transform: translate(-50%, -50%); /* 通过平移将其从中心调整到完全居中 */
  display: none; /* 初始隐藏 */
  z-index: 4;
  width: 100%;
  align-items: center;
  justify-content: center;

}

#popup .popup-content {
  position: relative;
  padding: 20px;
  max-width: 600px;
  max-height: 80%;
  overflow-y: auto;
  background-color: #f2f2f7;
  border-radius: 10px;
}

#close-btn {
  position: absolute;
  top: 10px;
  right: 10px;
  cursor: pointer;
  font-size: 20px;

  font-weight: bold;
}

#satellite-feqinfo {
  max-height: 400px; /* 设定最大高度 */
  overflow-y: auto;  /* 超出时出现垂直滚动条 */
}


@media (prefers-color-scheme: dark) {
    body {
        background-color: #2c2c2c; /* 深色模式下的背景色 */
    }

    #info-bar {
        background-color: #0a1649; /* 深色模式下的顶部信息栏背景色 */
    }

        #doppler-info {
        color: #ffffff;
    }



    #progress-bar-container {
        background-color: #444; /* 深色模式下的进度条背景色 */
    }

    #progress-bar {
        background-color: #56c6c6; /* 深色模式下的进度条颜色 */
    }

    #download-link {
        color: #ddd; /* 深色模式下下载链接的颜色 */
    }

    #popup .popup-content {
        background-color: #333; /* 深色模式下弹窗背景色 */
        color: #fff; /* 深色模式下的文字颜色 */
    }

    #satellite-feqinfo {
        color: #ccc; /* 深色模式下信息区域的文字颜色 */
    }
                    .link {
      color: #ddd; /* 或者选择其他合适的颜色，如蓝色 */
    }

                    #made {
      color: #ddd; /* 或者选择其他合适的颜色，如蓝色 */
}

.arrow {

        border-top-color: #94ff00;       /* 下边框为红色，形成三角形 */

}

    .compass-circle-outer {
        stroke: white;
    }
    
    .compass-circle-30,
    .compass-circle-60 {
        stroke: gray;
    }
    
    .direction-text {
        fill: white;
    }
    
    .compass-center {
        fill: white;
    }
    
    .tick-marks line {
        stroke: lightgray;
    }




}

</style>


<body>

    <div id="info-bar">
        <p id="satellite-name" style="font-weight:bold;"></p>
        <p id="satellite-info"></p>
        <p id="pass-info"></p>
        <p id="time-info"></p>
    </div>
<!-- 在progress-bar-container中添加时间显示 -->
<div id="progress-bar-container" style="position: relative; height: 20px; background: #eee;">
  <div id="progress-bar" style="height: 100%; background: #76c7c0; width: 0%; position: relative;">
      <!-- 时间标签直接位于进度条末端 -->
      <div id="elapsed-time" style="position: absolute; top: -14px; right: 0; font-size: 12px;color: rgb(255, 255, 255);"></div>
      <div id="remaining-time" style="position: absolute; bottom: -14px; right: 0; font-size: 12px;"></div>
  </div>
</div>
<div id="canvas-container">
    <canvas id="trajectory-canvas" width="300" height="300"></canvas>
    <svg id="trajectory-svg" width="300" height="300"></svg>
    <div class="compass">

        <!-- 替换 canvas 为 SVG -->
        <!-- <canvas class="compass-circle" id="compass-background" width="300" height="300" z-index="3" ></canvas> -->
        <svg class="compass-background" id="compass-backgroundsvg" width="300" height="300" viewBox="-150 -150 300 300">
                        <!-- 刻度线 -->
            <g class="tick-marks"></g>
            <!-- 外圈圆环 -->
            <circle class="compass-circle-outer" cx="0" cy="0" r="140" fill="none" stroke="#494953" stroke-width="3"/>
            
            <!-- 30°和60°圆环 -->
            <circle class="compass-circle-30" cx="0" cy="0" r="93.3" fill="none" stroke="gray" stroke-width="1" stroke-dasharray="5,5"/>
            <circle class="compass-circle-60" cx="0" cy="0" r="46.6" fill="none" stroke="gray" stroke-width="1" stroke-dasharray="5,5"/>
            

            
            <!-- 方向标记 -->
            <g class="cardinal-marks">
                <text x="0" y="-110" text-anchor="middle" class="direction-text">🇳</text>
                <text x="0" y="120" text-anchor="middle" class="direction-text">🇸</text>
            </g>
            
            <!-- 中心点 -->
            <circle class="compass-center" cx="0" cy="0" r="3" fill="#494953"/>
        </svg>
        <div class="arrow"></div>
    </div>


    <div id="elevation-bar" style="position: absolute; left: -25px; top: 0; height: 300px; width: 20px; background-color: #ddd; border: 0px solid #999; border-radius: 3px;">
    <div id="satellite-elevation" style="position: absolute; left: 1px; width: 18px; height: 18px; background-color: #e17822; border-radius: 50%;"></div>
    <div id="arrow-elevation" style="position: absolute; left: 6px; width: 8px; height: 8px; background-color: #186548; border-radius: 50%;"></div>





</div>

   <!-- <canvas id="satorbitpoint" width="300" height="300"></canvas> -->
    <svg id="satorbitpointsvg" width="300" height="300"></svg>


</div>

        <p id="doppler-info"></p>

<div class="button-container">


    <button class="info-btn" id="info-btn">多普勒跟踪</button>

    <div>
      <!-- Record button -->
      <button id="record-btn" class="record-btn">开始录音</button>
      <button id="download-btn"  class="download-btn" style="display: none;">下载音频</button>
    </div>



    </div>

        <button class="start-btn" >iOS设备传感器授权</button>


        <div id="popup" class="popup">
  <div class="popup-content">
    <button id="close-btn" class="close-btn">×</button>
    <div id="satellite-feqinfo"></div>
  </div>
</div>



</body>




    <script src="satellite.js"></script>

  <script>
    //刻度
     // 声明一个全局变量，用于在实时多普勒计算中判断频偏方向
      let previousdistancedoppler = null;
    //const compassBackground = document.getElementById('compass-background');
    //背景改SVG const compassCtx = compassBackground.getContext('2d');
    const compassCircle = document.querySelector(".compass-circle");
    const compassbackground = document.getElementById('compass-backgroundsvg');

    const myPoint = document.querySelector(".my-point");
    const startBtn = document.querySelector(".start-btn");
    const isIOS =
      navigator.userAgent.match(/(iPod|iPhone|iPad)/) &&
      navigator.userAgent.match(/AppleWebKit/);

      //const satpointCtx = document.getElementById('satorbitpoint').getContext('2d');




      //录音相关
      let recordingInterval; // 用于存储定时器的 ID
let recordingDuration = 0; // 录音持续时间（秒）





      //录音相关





    function init() {
        startBtn.addEventListener("click", startCompass);
      //navigator.geolocation.getCurrentPosition(locationHandler);

      if (!isIOS) {
        window.addEventListener("deviceorientationabsolute", handler, true);
      }
    }

        // 设置默认语言
        let currentLang = localStorage.getItem('lang') || 'zh';
    currentLang = localStorage.getItem('lang')
          const recordingTranslations = {  
    zh: {  
        startRecord: "开始录音",  
        stopRecord: "结束录音",  
        downloadAudio: "下载音频"  
    },  
    en: {  
        startRecord: "Start record",  
        stopRecord: "Stop record",   
        downloadAudio: "Download audio"  
    }  
};
window.onload = function () {

    const urlParams = new URLSearchParams(window.location.search);
    const index = urlParams.get('index');
    // 获取 localStorage 中保存的卫星数据
    const satelliteData = JSON.parse(localStorage.getItem('selectedorbit'));
    const selectedPass = satelliteData[index - 1];  // 索引从 1 开始，数组从 0 开始
    const trajectoryCtx = document.getElementById('trajectory-canvas').getContext('2d');
    const trajectorySVG = document.getElementById('trajectory-svg');



    let intervalId=-1; // 存储定时器ID


    // 绘制罗盘背景
    //drawCompassBackground(compassCtx);
    drawCompassbackground();




    // 显示卫星信息

    const satelliteName = selectedPass.satelliteName
    // 从 localStorage 获取 satellites 数据
    const satellites = JSON.parse(localStorage.getItem('satellites'));
    // 查找匹配的卫星
    const satellited = satellites.find(s => s.name === satelliteName);
 

    document.title = '🌎' + satelliteName;
    const satelliteTLE1 = satellited.tle[0];
    const satelliteTLE2 = satellited.tle[1];


    if (satelliteName && satelliteTLE1 && satelliteTLE2) {
        const satrec = satellite.twoline2satrec(satelliteTLE1, satelliteTLE2);

        const observerGd = {
            latitude: satellite.degreesToRadians(parseFloat(localStorage.getItem('latitude'))),
            longitude: satellite.degreesToRadians(parseFloat(localStorage.getItem('longitude'))),
            height: parseFloat(localStorage.getItem('altitude')) / 1000
        };



// 获取当前时间
const currentTime = new Date();

// 将 selectedPass.entryTime 和 selectedPass.exitTime 转换为 Date 对象
const entryTime = new Date(selectedPass.entryTime);
const exitTime = new Date(selectedPass.exitTime);

if (currentLang == 'zh') {
// 格式化时间
const formattedEntryTime = entryTime.toLocaleString('zh-CN', {
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
});

const formattedExitTime = exitTime.toLocaleString('zh-CN', {
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
});


document.getElementById('satellite-name').textContent = `🛰${selectedPass.satelliteName} `;
document.getElementById('satellite-info').textContent = `📍当前方位：° 仰角：° | 🔝预测仰角：${selectedPass.highestElevation}° `;
document.getElementById('pass-info').textContent = `🔼开始：${formattedEntryTime}  | 🔽结束：${formattedExitTime} `;
document.getElementById('time-info').textContent = "🕜当前时间：";
document.getElementById('info-btn').textContent = "多普勒跟踪";


    const satelliteElevation = document.getElementById('satellite-elevation');
        satelliteElevation.style.display = 'none';


     // 绘制卫星过境轨迹
    trajectoryPoints=drawTrajectorySVG(trajectorySVG, selectedPass, satrec, observerGd);


        setInterval(() => {
            const now = new Date();
            const positionAndVelocity = satellite.propagate(satrec, now);
            const gmst = satellite.gstime(now);

            const positionEci = positionAndVelocity.position;
            const lookAngles = satellite.ecfToLookAngles(
                observerGd,
                satellite.eciToEcf(positionEci, gmst)
            );

            const elevationdg =satellite.radiansToDegrees(lookAngles.elevation).toFixed(2);
            const azimuthdg = satellite.radiansToDegrees(lookAngles.azimuth).toFixed(2);
            const distance = satellite.eciToGeodetic(positionEci).height.toFixed(2);
            const height = positionEci.z.toFixed(2);


            document.getElementById('satellite-name').textContent = `🛰${selectedPass.satelliteName} `;
            document.getElementById('satellite-info').textContent = `📍当前方位：${azimuthdg}° 仰角：${elevationdg}° | 🔝预测仰角：${selectedPass.highestElevation}° `;
            document.getElementById('pass-info').textContent = `🔼开始：${formattedEntryTime}  | 🔽结束：${formattedExitTime}`;

const formattedTime = now.toLocaleString('zh-CN', {
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
});

// 判断时间状态并设置显示信息
let timeInfo = `🕜当前时间：${formattedTime}`;

if (now >= entryTime && now <= exitTime) {
    // 如果当前时间在 entryTime 和 exitTime 之间，计算距离结束时间的剩余时间
    const timeRemaining = exitTime - now;
    const hours = Math.floor(timeRemaining / (1000 * 60 * 60));
    const minutes = Math.floor((timeRemaining % (1000 * 60 * 60)) / (1000 * 60));
    const seconds = Math.floor((timeRemaining % (1000 * 60)) / 1000);
    timeInfo += ` | ⌛距离结束：${hours}h ${minutes}m ${seconds}s`;
        //updateSatellitePosition(satpointCtx, trajectoryPoints);
        updateSatellitePositionsvg(trajectoryPoints);
} else if (now < entryTime) {
    // 如果当前时间在 entryTime 之前，计算距离开始时间的剩余时间
    const timeRemaining = entryTime - now;
    const hours = Math.floor(timeRemaining / (1000 * 60 * 60));
    const minutes = Math.floor((timeRemaining % (1000 * 60 * 60)) / (1000 * 60));
    const seconds = Math.floor((timeRemaining % (1000 * 60)) / 1000);
    timeInfo += ` | ⌛距离开始：${hours}h ${minutes}m ${seconds}s`;
    const satelliteElevation = document.getElementById('satellite-elevation');
        satelliteElevation.style.display = 'none';
        //satpointCtx.clearRect(0, 0, 300, 300);
    const trajectorySvg = document.getElementById('satorbitpointsvg');
    trajectorySvg.innerHTML = '';

} else if (now > exitTime) {
    // 如果当前时间在 exitTime 之后，只显示当前时间
    timeInfo = `🕜当前时间：${formattedTime}`;
    const satelliteElevation = document.getElementById('satellite-elevation');
        satelliteElevation.style.display = 'none';
        //satpointCtx.clearRect(0, 0, 300, 300);
        const trajectorySvg = document.getElementById('satorbitpointsvg');
        trajectorySvg.innerHTML = '';
}

// 更新显示内容
document.getElementById('time-info').textContent = timeInfo;
       updateProgressBar(entryTime, exitTime, now);


        }, 1000);
        } else {

// 格式化时间

// 获取按钮元素
const button = document.querySelector('.start-btn');

// 修改按钮文字
button.textContent = 'iOS Device Sensor Authorization';


const formattedEntryTime = entryTime.toLocaleString('zh-CN', {
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
});

const formattedExitTime = exitTime.toLocaleString('zh-CN', {
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
});




document.getElementById('satellite-name').textContent = `🛰${selectedPass.satelliteName} `;
document.getElementById('satellite-info').textContent = `📍AzNow: ° ElNow: ° 🔝MaxEl：${selectedPass.highestElevation}° `;
document.getElementById('pass-info').textContent = `🔼Start: ${formattedEntryTime} | 🔽End: ${formattedExitTime} `;
document.getElementById('time-info').textContent = "";
document.getElementById('info-btn').textContent = "Sat Freq&Doppler Info";
document.getElementById('record-btn').textContent = "Start record";
document.getElementById('download-btn').textContent = "Dwonload audio";
document.getElementById('info-btn').textContent = "Sat Freq Info";




    const satelliteElevation = document.getElementById('satellite-elevation');
        satelliteElevation.style.display = 'none';




     // 绘制卫星过境轨迹
    trajectoryPoints=drawTrajectorySVG(trajectorySVG, selectedPass, satrec, observerGd);



        setInterval(() => {
            const now = new Date();
            const positionAndVelocity = satellite.propagate(satrec, now);
            const gmst = satellite.gstime(now);

            const positionEci = positionAndVelocity.position;
            const lookAngles = satellite.ecfToLookAngles(
                observerGd,
                satellite.eciToEcf(positionEci, gmst)
            );

            const elevationdg =satellite.radiansToDegrees(lookAngles.elevation).toFixed(2);
            const azimuthdg = satellite.radiansToDegrees(lookAngles.azimuth).toFixed(2);
            const distance = satellite.eciToGeodetic(positionEci).height.toFixed(2);
            const height = positionEci.z.toFixed(2);


            document.getElementById('satellite-name').textContent = `🛰${selectedPass.satelliteName} `;
            document.getElementById('satellite-info').textContent = `📍AzNow: ${azimuthdg}° ElNow: ${elevationdg}° | 🔝MaxEl: ${selectedPass.highestElevation}° `;
            document.getElementById('pass-info').textContent = `🔼Start: ${formattedEntryTime} | 🔽End: ${formattedExitTime} `;

const formattedTime = now.toLocaleString('zh-CN', {
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
});

// 判断时间状态并设置显示信息
let timeInfo = `🕜${formattedTime}`;

if (now >= entryTime && now <= exitTime) {
    // 如果当前时间在 entryTime 和 exitTime 之间，计算距离结束时间的剩余时间
    const timeRemaining = exitTime - now;
    const hours = Math.floor(timeRemaining / (1000 * 60 * 60));
    const minutes = Math.floor((timeRemaining % (1000 * 60 * 60)) / (1000 * 60));
    const seconds = Math.floor((timeRemaining % (1000 * 60)) / 1000);
    timeInfo += `| ⌛End in: ${hours}h ${minutes}m ${seconds}s`;

        //updateSatellitePosition(satpointCtx, trajectoryPoints);
                updateSatellitePositionsvg(trajectoryPoints);

} else if (now < entryTime) {
    // 如果当前时间在 entryTime 之前，计算距离开始时间的剩余时间
    const timeRemaining = entryTime - now;
    const hours = Math.floor(timeRemaining / (1000 * 60 * 60));
    const minutes = Math.floor((timeRemaining % (1000 * 60 * 60)) / (1000 * 60));
    const seconds = Math.floor((timeRemaining % (1000 * 60)) / 1000);
    timeInfo += `| ⌛Start in: ${hours}h ${minutes}m ${seconds}s`;
    const satelliteElevation = document.getElementById('satellite-elevation');
        satelliteElevation.style.display = 'none';


                  //satpointCtx.clearRect(0, 0, 300, 300);
        const trajectorySvg = document.getElementById('satorbitpointsvg');
        trajectorySvg.innerHTML = '';
} else if (now > exitTime) {
    // 如果当前时间在 exitTime 之后，只显示当前时间
    timeInfo = `🕜${formattedTime}`;
    const satelliteElevation = document.getElementById('satellite-elevation');
        satelliteElevation.style.display = 'none';


                  //satpointCtx.clearRect(0, 0, 300, 300);
        const trajectorySvg = document.getElementById('satorbitpointsvg');
        trajectorySvg.innerHTML = '';
}

// 更新显示内容
document.getElementById('time-info').textContent = timeInfo;
       updateProgressBar(entryTime, exitTime, now);


        }, 1000);
        }
    }
};





/*function drawCompassBackground(ctx) {
            const centerX = 150;
            const centerY = 150;
            const radius = 140;


    // 检测是否为深色模式
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;

    // 设置颜色
    const strokeColor = isDarkMode ? 'white' : '#494953';  // 外圈和文字的颜色
    const fillColor = isDarkMode ? 'white' : '#494953';    // 中心点的颜色
    const circleStrokeColor = isDarkMode ? 'gray' : 'gray'; // 圆圈的颜色
    const tickColor = isDarkMode ? 'lightgray' : 'gray'; // 刻度线的颜色



            // Draw outer circle
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                ctx.strokeStyle = strokeColor;
            ctx.lineWidth = 3;
            ctx.stroke();


    // Draw center point
    ctx.beginPath();
    ctx.arc(centerX, centerY, 3, 0, 2 * Math.PI); // Small circle with radius 3
    ctx.fillStyle = fillColor; // 中心点的颜色
    ctx.fill();


            // Draw concentric circles for 30° and 60° elevation
            const circleAngles = [30, 60];
            circleAngles.forEach((elevation) => {
                const circleRadius = (radius * (90 - elevation)) / 90;
                ctx.beginPath();
                ctx.arc(centerX, centerY, circleRadius, 0, 2 * Math.PI);
                ctx.strokeStyle = 'gray';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
            });
            ctx.setLineDash([]); // Reset dash style

            // Draw cardinal directions
            const directions = [ '','N', '', 'S'];
            directions.forEach((dir, index) => {
                const angle = (index * 90) * (Math.PI / 180);
                const x = centerX + (radius - 40) * Math.cos(angle);
                const y = centerY - (radius - 20) * Math.sin(angle);
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = strokeColor; // 方向文字的颜色
                ctx.fillText(dir, x, y);
            });

            // Draw intermediate tick marks
            for (let i = 0; i < 360; i += 10) {
                const angle = (i - 90) * (Math.PI / 180);
                const x1 = centerX + radius * Math.cos(angle);
                const y1 = centerY - radius * Math.sin(angle);
                const x2 = centerX + (radius - 10) * Math.cos(angle);
                const y2 = centerY - (radius - 10) * Math.sin(angle);
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.strokeStyle = tickColor;
                ctx.lineWidth = i % 90 === 0 ? 2 : 1; // Thicker for cardinal directions
                ctx.stroke();
            }
        }*/

function drawCompassbackground() {
    const tickMarksGroup = document.querySelector('.tick-marks');
    
    // 清除现有刻度
    while (tickMarksGroup.firstChild) {
        tickMarksGroup.removeChild(tickMarksGroup.firstChild);
    }
    
    // 绘制刻度线
    for (let i = 0; i < 360; i += 10) {
        const angle = (i - 90) * (Math.PI / 180);
        const r1 = 140;
        const r2 = i % 90 === 0 ? 125 : 130;
        
        const x1 = Math.cos(angle) * r1;
        const y1 = Math.sin(angle) * r1;
        const x2 = Math.cos(angle) * r2;
        const y2 = Math.sin(angle) * r2;
        
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("x1", x1);
        line.setAttribute("y1", y1);
        line.setAttribute("x2", x2);
        line.setAttribute("y2", y2);
        line.setAttribute("stroke", "gray");
        line.setAttribute("stroke-width", i % 90 === 0 ? "2" : "1");
        
        tickMarksGroup.appendChild(line);
    }
}


/*window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', function(event) {
    //背景改SVG drawCompassBackground(compassCtx);  // 重新绘制
    const satelliteData = JSON.parse(localStorage.getItem('selectedorbit'));
        const urlParams = new URLSearchParams(window.location.search);
    const index = urlParams.get('index');
        const selectedPass = satelliteData[index - 1];  // 索引从 1 开始，数组从 0 开始
        const satelliteName = selectedPass.satelliteName
            // 从 localStorage 获取 satellites 数据
    const satellites = JSON.parse(localStorage.getItem('satellites'));
    // 查找匹配的卫星
    const satellited = satellites.find(s => s.name === satelliteName);


    const satelliteTLE1 = satellited.tle[0];
    const satelliteTLE2 = satellited.tle[1];






        const satrec = satellite.twoline2satrec(satelliteTLE1, satelliteTLE2);

        const observerGd = {
            latitude: satellite.degreesToRadians(parseFloat(localStorage.getItem('latitude'))),
            longitude: satellite.degreesToRadians(parseFloat(localStorage.getItem('longitude'))),
            height: 0

}

        const trajectoryCtx = document.getElementById('trajectory-canvas').getContext('2d');
        const trajectorySVG = document.getElementById('trajectory-svg');



    trajectoryPoints=drawTrajectorySVG(trajectorySVG, selectedPass, satrec, observerGd);
    satpointCtx.clearRect(0, 0, 300, 300)
    //trajectoryCtx.clearRect(0, 0, 300, 300)
    drawTrajectorySVG(trajectorySVG, selectedPass, satrec, observerGd);
            const now = new Date();
            const entryTime = new Date(selectedPass.entryTime);
const exitTime = new Date(selectedPass.exitTime);

if (now >= entryTime && now <= exitTime) {
    // 如果当前时间在 entryTime 和 exitTime 之间，计算距离结束时间的剩余时间
    const timeRemaining = exitTime - now;
    const hours = Math.floor(timeRemaining / (1000 * 60 * 60));
    const minutes = Math.floor((timeRemaining % (1000 * 60 * 60)) / (1000 * 60));
    const seconds = Math.floor((timeRemaining % (1000 * 60)) / 1000);
    timeInfo += `，距离结束：${hours}h ${minutes}m ${seconds}s`;
        //updateSatellitePosition(satpointCtx, trajectoryPoints);
                updateSatellitePositionsvg(trajectoryPoints);
} 

});*/

function getRadiusForElevation(elevation, radius) {
    if (elevation <= 30) return radius - (radius * 0.25) * (elevation / 30);
    if (elevation <= 60) return radius * 0.75 - (radius * 0.25) * ((elevation - 30) / 30);
    return radius * 0.5 - (radius * 0.25) * ((elevation - 60) / 30);
}

// 绘制轨迹曲线
function drawTrajectory(ctx, selectedPass, satrec, observerGd) {


    const startTime = new Date(selectedPass.entryTime);
    const endTime = new Date(selectedPass.exitTime);

   const steps = 1000;
    const timeStep = (endTime - startTime) / steps;


    const trajectoryPoints = [];
    // 检测是否为深色模式
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;

    // 设置颜色
    const trajectoryColor = isDarkMode ? 'cyan' : '#007aff'; // 轨迹线的颜色
    const arrowColor = isDarkMode ? '#94ff00' : 'red';     // 箭头的颜色
    const pointColor = isDarkMode ? 'yellow' : 'green'; // 轨迹点的颜色


    
    // Loop through selectedPass (pass times or observations) and calculate satellite position
    for (let i = 0; i <= steps; i++) {
        const passTime = new Date(startTime.getTime() + i * timeStep);


        // Get the satellite position at this pass time
        const positionAndVelocity = satellite.propagate(satrec, passTime);
        const gmst = satellite.gstime(passTime);
        const positionEci = positionAndVelocity.position;

        // Get the look angles (elevation and azimuth) at this time
        const lookAngles = satellite.ecfToLookAngles(
            observerGd,
            satellite.eciToEcf(positionEci, gmst)
        );

        const elevation = satellite.radiansToDegrees(lookAngles.elevation);
        const azimuth = satellite.radiansToDegrees(lookAngles.azimuth);

        // Only consider valid look angles (elevation between 0 and 90 degrees)
        if (elevation > 0 && elevation <= 90) {
            const centerX = 150;
            const centerY = 150;
            const radius = 140;

            // Map elevation to a radius on the compass
            const satelliteRadius = radius * (90 - elevation) / 90;

            // Calculate the x, y coordinates of the satellite on the compass
            const satelliteX = centerX + satelliteRadius * Math.cos((90 - azimuth) * (Math.PI / 180));
            const satelliteY = centerY - satelliteRadius * Math.sin((90 - azimuth) * (Math.PI / 180));

            // Store the trajectory points
            trajectoryPoints.push({ x: satelliteX, y: satelliteY, time: passTime, eleva:elevation});
        }
    } 

    // Draw the trajectory line connecting all points
    ctx.beginPath();
    ctx.moveTo(trajectoryPoints[0].x, trajectoryPoints[0].y);

    for (let i = 1; i < trajectoryPoints.length; i++) {
        ctx.lineTo(trajectoryPoints[i].x, trajectoryPoints[i].y);

    }
    ctx.strokeStyle = trajectoryColor; // 轨迹线的颜色
    ctx.lineWidth = 2;
    ctx.stroke();


    // 绘制调试点
    //drawDebugPoint(ctx, trajectoryPoints[0].x, trajectoryPoints[0].y, 'green', 'Start');
    //drawDebugPoint(ctx, trajectoryPoints[(trajectoryPoints.length+1)/2].x, trajectoryPoints[(trajectoryPoints.length+1)/2].y, 'red', 'El'); 
    //drawDebugPoint(ctx, trajectoryPoints[trajectoryPoints.length-1].x, trajectoryPoints[trajectoryPoints.length-1].y, 'green', '');

/*if (elevation < 0) {
        // 当仰角小于或等于0时，确保卫星点不显示
        ctx.clearRect(0, 0, 300, 300); // 清空图层，避免显示卫星点
    }*/


 // Function to draw arrows
    function drawArrow(x1, y1, x2, y2, color) {
        const headLength = 10; // Length of the arrowhead
        const dx = x2 - x1;
        const dy = y2 - y1;
        const angle = Math.atan2(dy, dx);

// Draw line
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.stroke();

        // Draw arrowhead
        ctx.beginPath();
        ctx.moveTo(x2, y2);
        ctx.lineTo(x2 - headLength * Math.cos(angle - Math.PI / 6), y2 - headLength * Math.sin(angle - Math.PI / 6));
        ctx.lineTo(x2 - headLength * Math.cos(angle + Math.PI / 6), y2 - headLength * Math.sin(angle + Math.PI / 6));
        ctx.lineTo(x2, y2);
        ctx.fillStyle = color;
        ctx.fill();
    }

    // Draw arrows at 1/3 and 2/3 of the trajectory
    const oneThirdIndex = Math.floor(trajectoryPoints.length   / 2);
    //const twoThirdIndex = Math.floor(trajectoryPoints.length * 2 / 3);

    if (trajectoryPoints.length > 2) {
        const arrow1Start = trajectoryPoints[oneThirdIndex - 1];
        const arrow1End = trajectoryPoints[oneThirdIndex];
        drawArrow(arrow1Start.x, arrow1Start.y, arrow1End.x, arrow1End.y, arrowColor);

        /*const arrow2Start = trajectoryPoints[twoThirdIndex - 1];
        const arrow2End = trajectoryPoints[twoThirdIndex];
        drawArrow(arrow2Start.x, arrow2Start.y, arrow2End.x, arrow2End.y, 'red');*/
    }



    return trajectoryPoints;
}



function drawTrajectorySVG(svgContainer, selectedPass, satrec, observerGd) {
    const startTime = new Date(selectedPass.entryTime);
    const endTime = new Date(selectedPass.exitTime);

    const steps = 1000;
    const timeStep = (endTime - startTime) / steps;

    const trajectoryPoints = [];
    // 检测是否为深色模式
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;

    // 设置颜色
    const trajectoryColor = isDarkMode ? 'cyan' : '#007aff'; // 轨迹线的颜色
    const arrowColor = isDarkMode ? '#94ff00' : 'red';     // 箭头的颜色
    const pointColor = isDarkMode ? 'yellow' : 'green'; // 轨迹点的颜色

    const centerX = 150;
    const centerY = 150;
    const radius = 140;

    // Loop through selectedPass (pass times or observations) and calculate satellite position
    for (let i = 0; i <= steps; i++) {
        const passTime = new Date(startTime.getTime() + i * timeStep);

        // Get the satellite position at this pass time
        const positionAndVelocity = satellite.propagate(satrec, passTime);
        const gmst = satellite.gstime(passTime);
        const positionEci = positionAndVelocity.position;

        // Get the look angles (elevation and azimuth) at this time
        const lookAngles = satellite.ecfToLookAngles(
            observerGd,
            satellite.eciToEcf(positionEci, gmst)
        );

        const elevation = satellite.radiansToDegrees(lookAngles.elevation);
        const azimuth = satellite.radiansToDegrees(lookAngles.azimuth);

        // Only consider valid look angles (elevation between 0 and 90 degrees)
        if (elevation > 0 && elevation <= 90) {
            // Map elevation to a radius on the compass
            const satelliteRadius = radius * (90 - elevation) / 90;

            // Calculate the x, y coordinates of the satellite on the compass
            const satelliteX = centerX + satelliteRadius * Math.cos((90 - azimuth) * (Math.PI / 180));
            const satelliteY = centerY - satelliteRadius * Math.sin((90 - azimuth) * (Math.PI / 180));

            // Store the trajectory points
            trajectoryPoints.push({ x: satelliteX, y: satelliteY, time: passTime, eleva: elevation });
        }
    }

    // 清空 SVG 容器内容
    while (svgContainer.firstChild) {
        svgContainer.removeChild(svgContainer.firstChild);
    }

    // 绘制轨迹线
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    let pathData = `M ${trajectoryPoints[0].x},${trajectoryPoints[0].y}`;
    for (let i = 1; i < trajectoryPoints.length; i++) {
        pathData += ` L ${trajectoryPoints[i].x},${trajectoryPoints[i].y}`;
    }
    path.setAttribute('d', pathData);
    path.setAttribute('stroke', trajectoryColor);
    path.setAttribute('stroke-width', '2');
    path.setAttribute('fill', 'none');
    svgContainer.appendChild(path);

    // Function to draw arrows
    function drawArrow(x1, y1, x2, y2, color) {
        const headLength = 10; // Length of the arrowhead
        const dx = x2 - x1;
        const dy = y2 - y1;
        const angle = Math.atan2(dy, dx);

        // Draw arrow line
        const arrowLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        arrowLine.setAttribute('x1', x1);
        arrowLine.setAttribute('y1', y1);
        arrowLine.setAttribute('x2', x2);
        arrowLine.setAttribute('y2', y2);
        arrowLine.setAttribute('stroke', color);
        arrowLine.setAttribute('stroke-width', '2');
        svgContainer.appendChild(arrowLine);

        // Draw arrowhead
        const arrowHead = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        const points = `
            ${x2},${y2} 
            ${x2 - headLength * Math.cos(angle - Math.PI / 6)},${y2 - headLength * Math.sin(angle - Math.PI / 6)}
            ${x2 - headLength * Math.cos(angle + Math.PI / 6)},${y2 - headLength * Math.sin(angle + Math.PI / 6)}
        `;
        arrowHead.setAttribute('points', points);
        arrowHead.setAttribute('fill', color);
        svgContainer.appendChild(arrowHead);
    }

    // Draw arrows at 1/3 and 2/3 of the trajectory
    const oneThirdIndex = Math.floor(trajectoryPoints.length / 2);
    if (trajectoryPoints.length > 2) {
        const arrow1Start = trajectoryPoints[oneThirdIndex - 1];
        const arrow1End = trajectoryPoints[oneThirdIndex];
        drawArrow(arrow1Start.x, arrow1Start.y, arrow1End.x, arrow1End.y, arrowColor);
    }

    return trajectoryPoints;
}


// 调试函数：绘制轨迹点位置
function drawDebugPoint(ctx, x, y, color, label) {
    ctx.beginPath();
    ctx.arc(x, y, 3, 0, 2 * Math.PI);
    ctx.fillStyle = color;
    ctx.fill();
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(label, x+5, y - 5);
}

// 生成轨迹上的点数组
/*function generateTrajectoryPoints(entryX, entryY, highestX, highestY, exitX, exitY, steps = 100) {
    const points = [];
    for (let t = 0; t <= 1; t += 1 / steps) {
        const x = Math.pow(1 - t, 2) * entryX +
                  2 * (1 - t) * t * highestX +
                  Math.pow(t, 2) * exitX;
        const y = Math.pow(1 - t, 2) * entryY +
                  2 * (1 - t) * t * highestY +
                  Math.pow(t, 2) * exitY;
        points.push({ x, y });
    }
    return points;
}*/


// 投射红点到曲线的最近点
/*function projectPointToCurve(x, y, trajectoryPoints) {
    let minDistance = Infinity;
    let closestPoint = { x: 0, y: 0 };

    trajectoryPoints.forEach(point => {
        const distance = Math.hypot(point.x - x, point.y - y);
        if (distance < minDistance) {
            minDistance = distance;
            closestPoint = point;
        }
    });

    return closestPoint;
}*/

// 更新卫星位置并绘制实时轨迹
function updateSatellitePosition(ctx, trajectoryPoints) { 
    const now = new Date();

        // 找到当前时间最近的轨迹点
    let closestPoint = trajectoryPoints[0];

    let minTimeDiff = Math.abs(now - closestPoint.time);
        for (let i = 1; i < trajectoryPoints.length; i++) {
        const timeDiff = Math.abs(now - trajectoryPoints[i].time);
        if (timeDiff < minTimeDiff) {
            closestPoint = trajectoryPoints[i];
            minTimeDiff = timeDiff;

        }
    }


// 检测是否为深色模式
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;

    // 设置颜色
    const satelliteColor = isDarkMode ? 'cyan' : '#007aff';  // 卫星点颜色
    const lineColor = isDarkMode ? 'lime' : '#007aff';       // 中心到卫星的连线颜色
    const elevationBarColor = isDarkMode ? '#333' : '#ddd'; // 仰角条背景色
    const elevationPointColor = isDarkMode ? '#ff0' : '#0066cc'; // 仰角点颜色




                // 显示卫星的仰角
    const elevationBar = document.getElementById('elevation-bar');
    const satelliteElevation = document.getElementById('satellite-elevation');
    satelliteElevation.style.display = 'block';  // 或 'inline' 根据需要选择

    const barHeight = elevationBar.offsetHeight-9;
// 需要确保 elevation 在 0 到 90 之间


if (closestPoint.eleva > 0 && closestPoint.eleva <= 90) {



    // 映射卫星的仰角到仰角条的位置 (0 - 90度 -> 0 - barHeight)
    const satelliteElevationDistance = (90 - closestPoint.eleva) / 90 * barHeight;

    // 更新蓝色点的位置
    satelliteElevation.style.top = `${satelliteElevationDistance  - satelliteElevation.offsetHeight / 2}px`;


} else {
    // 如果 elevation 不在有效范围内，可以选择不显示或者显示一个默认值
    satelliteElevation.style.display = 'none';
}

    // 清空图层，重新绘制当前卫星点
ctx.clearRect(0, 0, 300, 300);

if (closestPoint.eleva > 0 && closestPoint.eleva <= 90) {

    const centerX = 150;
    const centerY = 150;

    // 绘制卫星实时位置
    ctx.beginPath();
    ctx.arc(closestPoint.x, closestPoint.y, 5, 0, 2 * Math.PI);
    // 绘制黑色轮廓
ctx.strokeStyle = 'black';  // 设置轮廓颜色为黑色
ctx.lineWidth = 2;          // 设置轮廓宽度
ctx.stroke();               // 绘制轮廓

    ctx.fillStyle = satelliteColor; // 使用深色模式的卫星颜色
    ctx.fill();

    // 绘制中心到卫星的连线
    ctx.beginPath();
    ctx.moveTo(centerX, centerY);
    ctx.lineTo(closestPoint.x, closestPoint.y);
    ctx.strokeStyle = satelliteColor; // 使用深色模式的卫星颜色
    ctx.lineWidth = 1;
    ctx.stroke();


}else if (closestPoint.eleva < 0){

        ctx.clearRect(0, 0, 300, 300);


    }








    
}



// 更新卫星位置并绘制实时轨迹（SVG 版本）
function updateSatellitePositionsvg(trajectoryPoints) {
    const now = new Date();

    // 找到当前时间最近的轨迹点
    let closestPoint = trajectoryPoints[0];
    let minTimeDiff = Math.abs(now - closestPoint.time);

    for (let i = 1; i < trajectoryPoints.length; i++) {
        const timeDiff = Math.abs(now - trajectoryPoints[i].time);
        if (timeDiff < minTimeDiff) {
            closestPoint = trajectoryPoints[i];
            minTimeDiff = timeDiff;
        }
    }

    // 显示仰角条上的卫星仰角
    const elevationBar = document.getElementById('elevation-bar');
    const satelliteElevation = document.getElementById('satellite-elevation');
    satelliteElevation.style.display = 'block';

    const barHeight = elevationBar.offsetHeight - 9;

    if (closestPoint.eleva > 0 && closestPoint.eleva <= 90) {
        const satelliteElevationDistance = (90 - closestPoint.eleva) / 90 * barHeight;
        satelliteElevation.style.top = `${satelliteElevationDistance - satelliteElevation.offsetHeight / 2}px`;
    } else {
        satelliteElevation.style.display = 'none';
    }

    // 获取 SVG 容器和清空现有内容
    const trajectorySvg = document.getElementById('satorbitpointsvg');
    trajectorySvg.innerHTML = '';

    if (closestPoint.eleva > 0 && closestPoint.eleva <= 90) {
        const centerX = 150; // 圆心 X 坐标
        const centerY = 150; // 圆心 Y 坐标

        // 创建卫星点
        const satellitePoint = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        satellitePoint.setAttribute('cx', closestPoint.x);
        satellitePoint.setAttribute('cy', closestPoint.y);
        satellitePoint.setAttribute('r', 5);
        satellitePoint.setAttribute('fill', '#007aff'); // 卫星点颜色
        satellitePoint.setAttribute('stroke', 'black'); // 黑色轮廓
        satellitePoint.setAttribute('stroke-width', 2);

        // 创建中心到卫星的连线
        const satelliteLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        satelliteLine.setAttribute('x1', centerX);
        satelliteLine.setAttribute('y1', centerY);
        satelliteLine.setAttribute('x2', closestPoint.x);
        satelliteLine.setAttribute('y2', closestPoint.y);
        satelliteLine.setAttribute('stroke', '#007aff'); // 连线颜色
        satelliteLine.setAttribute('stroke-width', 1);

        // 将元素添加到 SVG
        trajectorySvg.appendChild(satelliteLine);
        trajectorySvg.appendChild(satellitePoint);
    }
}


    function startCompass() {
      if (isIOS) {
        DeviceOrientationEvent.requestPermission()
          .then((response) => {
            if (response === "granted") {
              window.addEventListener("deviceorientation", handler, true);
            } else {
              alert("has to be allowed!");
            }
          })
          .catch(() => alert("not supported"));
      }
    }


    function updateProgressBar(entryTime, exitTime, now) {
    const progressBar = document.getElementById('progress-bar');
    const elapsedDisplay = document.getElementById('elapsed-time');
    const remainingDisplay = document.getElementById('remaining-time');
    
    const totalDuration = exitTime - entryTime;
    const elapsedTime = Math.max(now - entryTime, 0);
    const remainingTime = Math.max(totalDuration - elapsedTime -1, 0);

    // 格式化为秒数
    const formatSeconds = ms => Math.round(ms/1000) + 's';
    
    // 更新显示
    elapsedDisplay.textContent = `T+` + formatSeconds(elapsedTime);
    remainingDisplay.textContent = formatSeconds(remainingTime);
    
    const progressPercentage = Math.min((elapsedTime / totalDuration) * 100, 100);
    progressBar.style.width = `${progressPercentage}%`;
    }





function handler(e) {

    const compass = e.webkitCompassHeading || Math.abs(e.alpha - 360);

    // Define the center of the compass
    const centerX = 150;
    const centerY = 150;

    // Rotate compass circle
    //背景改SVG  compassCircle.style.transform = `translate(-50%, -50%) rotate(${-compass}deg)`;
    //背景改SVG compassBackground.style.transform = `translate(-50%, -50%) rotate(${-compass}deg)`;
    compassbackground.style.transform = `rotate(${-compass}deg)`;

    // Rotate trajectory canvas
    const trajectoryCanvas = document.getElementById('trajectory-svg');
    trajectoryCanvas.style.transformOrigin = 'center';
    trajectoryCanvas.style.transform = `rotate(${-compass}deg)`;


    // 
    const satorbitpointCanvas = document.getElementById('satorbitpointsvg');
    satorbitpointCanvas.style.transformOrigin = 'center';
    satorbitpointCanvas.style.transform = `rotate(${-compass}deg)`;


     // Handle arrow position based on beta
    const beta = e.beta;  // Get the beta value from the event
    const arrow = document.querySelector('.arrow');

    // Radius of the compass circle
    const radius = 140; 

    // Map beta value to distance: 
    // When beta = 0, distance = radius (edge)
    // When beta = 90, distance = 0 (center)
    const distance = (90 - beta) / 90 * radius;  // Inverse the scaling to match your requirement

    // Calculate the Y position based on beta (upward or downward movement)
    const arrowY = centerY-50;  // Adjust Y position to move the arrow vertically
    const arrowX = centerX;  // Keep the arrow horizontally centered

   /* // Update arrow position
    if ( arrowY >=10 && arrowY<=150){
    arrow.style.top = `${arrowY - 10}px`; // Adjust top to position the arrow

} else if (arrowY>150) {
arrow.style.top = `${arrowY - 140}px`; // Adjust top to position the arrow

}


*/
    // Control red point visibility based on compass angle

    // 获取仰角条和黄点
const elevationBar = document.getElementById('elevation-bar');
const arrowElevation = document.getElementById('arrow-elevation');

// 高度条总长度
const barHeight = elevationBar.offsetHeight-9;

// 映射 beta (0 - 90) 到仰角条 (0 - barHeight)




if (beta > 90) {
    adjustedBeta = 90; // 如果 beta > 90，强制设为 90
} else if (beta < 0) {
    adjustedBeta = 0; // 如果 beta < 90，强制设为 0
} else {
    adjustedBeta = beta; // beta == 90 时，保持为 90
}

const elevationDistance = (90 - adjustedBeta) / 90 * barHeight;






// 更新红点位置

arrowElevation.style.top = `${elevationDistance - arrowElevation.offsetHeight / 2}px`;



}

    


  /*  let pointDegree;

    function locationHandler(position) {
      const { latitude, longitude } = position.coords;
      pointDegree = calcDegreeToPoint(latitude, longitude);

      if (pointDegree < 0) {
        pointDegree = pointDegree + 360;
      }
    }

 function calcDegreeToPoint(latitude, longitude) {
      // Qibla geolocation
      const point = {
        lat: 21.422487,
        lng: 39.826206
      };

      const phiK = (point.lat * Math.PI) / 180.0;
      const lambdaK = (point.lng * Math.PI) / 180.0;
      const phi = (latitude * Math.PI) / 180.0;
      const lambda = (longitude * Math.PI) / 180.0;
      const psi =
        (180.0 / Math.PI) *
        Math.atan2(
          Math.sin(lambdaK - lambda),
          Math.cos(phi) * Math.tan(phiK) -
            Math.sin(phi) * Math.cos(lambdaK - lambda)
        );
      return Math.round(psi);
    }
*/


        if (window.DeviceOrientationEvent) {
            window.addEventListener('deviceorientation', function (event) {
                /*var a = document.getElementById('alpha'),
                    b = document.getElementById('beta'),
                    g = document.getElementById('gamma'),*/

                    alpha = event.alpha,
                    beta = event.beta,
                    gamma = event.gamma;

                /*a.innerHTML = Math.round(alpha);
                b.innerHTML = Math.round(beta);
                g.innerHTML = Math.round(gamma);*/

                  // Update arrow and compass position
        handler(event);      



            }, false);
        } else {
            document.querySelector('body').innerHTML = '你的浏览器不支持陀螺仪';
        }




//频率表开始
document.addEventListener('DOMContentLoaded', function() {
  const infoButton = document.querySelector('.info-btn');
  const popup = document.getElementById('popup');
  const closeButton = document.getElementById('close-btn');
  const satelliteInfo = document.getElementById('satellite-feqinfo');
      const urlParams = new URLSearchParams(window.location.search);
    const index = urlParams.get('index');
  
  // Authorization token (use the correct token here)
  const authorizationToken = '04dbc5423ace07e1caad69925c275a4d4d48d342';

  infoButton.addEventListener('click', function() {




    const satelliteData = JSON.parse(localStorage.getItem('selectedorbit'));
    const selectedPass = satelliteData[index - 1];  // 索引从 1 开始，数组从 0 开始
    const satelliteName = selectedPass.satelliteName
    const satellites = JSON.parse(localStorage.getItem('satellites'));
    const satellited = satellites.find(s => s.name === satelliteName);

        // Fetch the selected satellite NORAD catalog ID from localStorage
    const selectedSatelliteTLE2 = satellited.tle[1];
    const selectedsat = satelliteName
    if (!selectedSatelliteTLE2) {
      alert('No satellite selected');
      return;
    }


    // Extract the NORAD catalog ID from TLE2 string (assuming it's the second part)
    const noradCatId = selectedSatelliteTLE2.split(' ')[1];
    // Check if we already have frequency information for this NORAD catalog ID in localStorage
    const storedData = localStorage.getItem('freqinfo');
    const freqInfo = storedData ? JSON.parse(storedData) : {};

    // Show loading text before fetching data
    satelliteInfo.innerHTML = '<p>Loading...</p>';

    // If we have data for this NORAD catalog ID, use it
    if (freqInfo[noradCatId]) {
      displayFrequencyData(freqInfo[noradCatId], selectedsat);
    } else {
      // Otherwise, fetch data from the API
      fetchSatelliteData(noradCatId, selectedsat);
    }

    // Show the popup
    popup.style.display = 'block';
  });

  // Close the popup when the close button is clicked
  closeButton.addEventListener('click', function() {
    popup.style.display = 'none';
  });

  // Close the popup if user clicks outside the popup content
  window.addEventListener('click', function(event) {
    if (event.target === popup) {
      popup.style.display = 'none';
    }
  });

  // Function to fetch data from the API
  function fetchSatelliteData(noradCatId, selectedsat) {
    const apiUrl = `https://c0rs.xanyi.eu.org/c0rs/?https://db.satnogs.org/api/transmitters/?alive=true&format=json&satellite__norad_cat_id=${noradCatId}&status=active`;

    fetch(apiUrl, {
      method: 'GET',
      headers: {
        'Accept': 'application/json',
        'Authorization': `Bearer ${authorizationToken}` // Adding the authorization header
      }
    })
    .then(response => response.json()) // Parse the JSON response
    .then(data => {
      if (data.length === 0) {
        satelliteInfo.innerHTML = '<p>No frequency information available.</p>';
      } else {
        // Add data to freqinfo with the corresponding noradCatId
        const freqInfo = JSON.parse(localStorage.getItem('freqinfo') || '{}');
        freqInfo[noradCatId] = data; // Store the data under the noradCatId

        // Store updated data back to localStorage
        localStorage.setItem('freqinfo', JSON.stringify(freqInfo));

        // Display the fetched data
        displayFrequencyData(data, selectedsat);
      }
    })
    .catch(error => {
      console.error('Error fetching satellite data:', error);
      satelliteInfo.innerHTML = '<p>Error fetching data.</p>';
    });
  }



});

//频率表结束




//录音开始
document.addEventListener('DOMContentLoaded', function() {
  const recordBtn = document.getElementById('record-btn');

  const downloadBtn = document.getElementById('download-btn');
  
  let isRecording = false;
  let mediaRecorder;
  let audioChunks = [];
  let audioBlob;
  let audioUrl;
  let audioFile;
    let fileSizeInMB = 0;

  // Function to handle recording button
// 修改 recordBtn.addEventListener('click', function() 中的内容  
recordBtn.addEventListener('click', function() {  
    if (isRecording) {  
        // Stop recording  
        mediaRecorder.stop();  
        recordBtn.textContent = recordingTranslations[currentLang].startRecord;  
        downloadBtn.style.display = 'inline-block';  
    } else {  
        // Start recording  
        recordBtn.textContent = recordingTranslations[currentLang].stopRecord;  
        startRecording();  
          
        audioChunks = [];  
        fileSizeInMB = 0;  
        downloadBtn.style.display = 'none';  
    }  
    isRecording = !isRecording;  
});

  // Function to update recording status (size and duration)
function updateRecordingStatus(audioChunks) {  
    recordingInterval = setInterval(() => {  
        const currentSize = audioChunks.reduce((total, chunk) => total + chunk.size, 0) / (1024 * 1024);  
        recordingDuration += 1;  
  
        const statusDisplay = document.getElementById('record-btn');  
        if (statusDisplay) {  
            const stopText = recordingTranslations[currentLang].stopRecord;  
            statusDisplay.textContent = `${stopText}(${currentSize.toFixed(2)} MB, ${recordingDuration}s)`;  
        }  
    }, 1000);  
}

// 停止更新录音状态
function stopRecordingStatus() {
  clearInterval(recordingInterval); // 停止定时器
  recordingDuration = 0; // 重置时长
}

  // Function to start recording
  function startRecording() {
    navigator.mediaDevices.getUserMedia({ audio: true })
      .then(function(stream) {
        mediaRecorder = new MediaRecorder(stream);
        mediaRecorder.start(1000);

        mediaRecorder.ondataavailable = function(event) {
          audioChunks.push(event.data);
        };

        updateRecordingStatus(audioChunks);

mediaRecorder.onstop = function() {  
    stream.getTracks().forEach(track => track.stop());  
    stopRecordingStatus();  
  
    audioBlob = new Blob(audioChunks, { type: 'audio/wav' });  
    audioUrl = URL.createObjectURL(audioBlob);  
    audioFile = new File([audioBlob], `${getSatelliteName()}-${getCurrentTimestamp()}.wav`, { type: 'audio/wav' });  
  
    fileSizeInMB = audioBlob.size / (1024 * 1024);  
  
    // 使用动态语言文本  
    const downloadText = recordingTranslations[currentLang].downloadAudio;  
    downloadBtn.textContent = `${downloadText} - ${fileSizeInMB.toFixed(2)}MB`;  
  
    downloadBtn.removeEventListener('click', downloadAudio);  
    downloadBtn.addEventListener('click', downloadAudio);  
};
      })
      .catch(function(error) {
        console.error("Error accessing audio devices:", error);
      });
  }


    // 下载音频的函数
  function downloadAudio() {
    const link = document.createElement('a');
    link.href = audioUrl;
    link.download = audioFile.name;
    link.click();
  }



  // Function to get the satellite name (you can replace this logic with actual satellite name)
  function getSatelliteName() {
    return localStorage.getItem('selectedSatelliteName') || 'Satellite';
  }

  // Function to get the current timestamp
  function getCurrentTimestamp() {
    const now = new Date();
    return `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')} ${String(now.getHours()).padStart(2, '0')}_${String(now.getMinutes()).padStart(2, '0')}_${String(now.getSeconds()).padStart(2, '0')}`;
  }
});

//录音结束


//多普勒功能

// Function to start tracking Doppler frequency
function startTrackingDoppler(downlink_low, uplink_low, description) {

    const closeButton = document.getElementById('close-btn');
    closeButton.click();

    // Clear any previous intervals
    if (window.dopplerInterval) {
        clearInterval(window.dopplerInterval);
    }



    // Set interval to update Doppler every second (1000ms)
    window.dopplerInterval = setInterval(() => {
        updateDoppler(downlink_low, uplink_low, description);
    }, 1000);

          /*  // 【新增】计算整个过境期间的多普勒频率，并在进度条上添加刻度
        computeDopplerTicks(downlink_low, uplink_low, description);*/


}


  // Function to format frequency to MHz (e.g., 136650000 => 136.650 MHz)
  function formatFrequency(freq) {
    return freq ? (freq / 1000000).toFixed(3) + ' MHz' : 'N/A';
  }


function updateDoppler(downlink_low, uplink_low,description) {
    // 获取当前时间
    const now = new Date();

    // 从 localStorage 获取必要的参数
    const satelliteData = JSON.parse(localStorage.getItem('selectedorbit'));
    const satellites = JSON.parse(localStorage.getItem('satellites'));
    const observerGd = {
        latitude: satellite.degreesToRadians(parseFloat(localStorage.getItem('latitude'))),
        longitude: satellite.degreesToRadians(parseFloat(localStorage.getItem('longitude'))),
        height: parseFloat(localStorage.getItem('altitude')) /1000 
    };

    // 获取卫星数据
    const satelliteName = satelliteData[0].satelliteName;
    const satellited = satellites.find(s => s.name === satelliteName);
    const satelliteTLE1 = satellited.tle[0];
    const satelliteTLE2 = satellited.tle[1];

    // 使用 TLE 数据生成卫星的 satrec 对象
    const satrec = satellite.twoline2satrec(satelliteTLE1, satelliteTLE2);

    // 使用 satellite.js 获取卫星当前的位置和速度
    const positionAndVelocity = satellite.propagate(satrec, now);
    const gmst = satellite.gstime(now);
    const positionEci = positionAndVelocity.position;
    const velocityEci = positionAndVelocity.velocity;

    // 将卫星的 ECI 位置和速度转换为 ECF
    const positionEcf = satellite.eciToEcf(positionEci, gmst);
    const velocityEcf = satellite.eciToEcf(velocityEci, gmst);

    // 获取观察者的 ECF 位置
    const observerEcf = satellite.geodeticToEcf(observerGd);






    // 计算多普勒因子（dopplerFactor）
    const dopplerFactor = satellite.dopplerFactor(observerEcf, positionEcf, velocityEcf);
    // 计算多普勒频偏（Downlink和Uplink）
    const dopplerShiftDownlink = dopplerFactor * downlink_low;
    const dopplerShiftUplink = dopplerFactor * uplink_low;

    // 判断dopplerFactor是否在增大或者变小

    const dx = positionEcf.x - observerEcf.x;
    const dy = positionEcf.y - observerEcf.y;
    const dz = positionEcf.z - observerEcf.z;


    const distancedoppler = Math.sqrt(dx * dx + dy * dy + dz * dz);
    let directionup = '';
    let directiondown = '';

      const urlParams = new URLSearchParams(window.location.search);
    const index = urlParams.get('index');

    const selectedPass = satelliteData[index - 1];  // 索引从 1 开始，数组从 0 开始
    const entryTime = new Date(selectedPass.entryTime);
    const exitTime = new Date(selectedPass.exitTime);
    // 获取最高点时间
    const highestTime = new Date(selectedPass.highestTime);


    if (previousdistancedoppler !== null) {
        if (distancedoppler > previousdistancedoppler) {
            // dopplerFactor增大，表示卫星在远离
            directionup = '+';
            directiondown = '-';
        } else if (distancedoppler < previousdistancedoppler) {
            // dopplerFactor变小，表示卫星在接近
            directionup = '-';
            directiondown = '+';
        }
    }

    // 更新previousDopplerFactor为当前的dopplerFactor
    previousdistancedoppler = distancedoppler;


    // 计算频率差异并转换为 kHz
    const dopplerShiftDifferencedown = ((dopplerShiftDownlink-downlink_low ) / 1000).toFixed(2);
    const dopplerShiftDifferenceup = ((dopplerShiftUplink-uplink_low )/ 1000).toFixed(2);
    const nowdopplerShiftDifferencedown = (dopplerShiftDownlink-downlink_low ) ;


    // 计算 SSTV 参考接收频率和最大偏差
    function calculateSSTVReference(timeOffset) {
 const futureTime = new Date(now.getTime() + timeOffset * 1000);



        const futurePosition = satellite.propagate(satrec, futureTime);

    const futuregmst = satellite.gstime(futureTime);
    const futurepositionEci = futurePosition.position;
    const futurevelocityEci = futurePosition.velocity;
        // 将卫星的 ECI 位置和速度转换为 ECF
    const futurepositionEcf = satellite.eciToEcf(futurepositionEci, futuregmst);
    const futurevelocityEcf = satellite.eciToEcf(futurevelocityEci, futuregmst);

        // 获取观察者的 ECF 位置
            const observerGd = {
        latitude: satellite.degreesToRadians(parseFloat(localStorage.getItem('latitude'))),
        longitude: satellite.degreesToRadians(parseFloat(localStorage.getItem('longitude'))),
        height: parseFloat(localStorage.getItem('altitude')) /1000 
    };


    const observerEcf = satellite.geodeticToEcf(observerGd);



    const futureDopplerFactor = satellite.dopplerFactor(observerEcf, futurepositionEcf, futurevelocityEcf);



        const futuredopplerShiftDownlink = futureDopplerFactor * parseFloat(downlink_low);
        const dopplerShiftDownlink = dopplerFactor * parseFloat(downlink_low);
        const futuredopplerShiftDifferencedown = (futuredopplerShiftDownlink-parseFloat(downlink_low) ) ;
        // 计算当前频率 currentDownlink
let currentDownlink;
if (now >= entryTime && now <= highestTime) {
    currentDownlink = parseFloat(downlink_low) + nowdopplerShiftDifferencedown;
} else if (now >= highestTime && now <= exitTime) {
    currentDownlink = parseFloat(downlink_low) - nowdopplerShiftDifferencedown;
}
// 计算未来频率 futureDownlink
let futureDownlink;
if (futureTime >= entryTime && futureTime <= highestTime) {
    futureDownlink = parseFloat(downlink_low) + futuredopplerShiftDifferencedown;
} else if (futureTime >= highestTime && futureTime <= exitTime) {
    futureDownlink = parseFloat(downlink_low) - futuredopplerShiftDifferencedown;
}

        const referenceFreq = ((currentDownlink + futureDownlink) / 2 / 1000000).toFixed(3);
        const maxDeviation = ((futureDownlink - currentDownlink) / 1000).toFixed(3);
        /*if (timeOffset == 36 ){
        console.log("now",new Date()); 
        console.log("futureTime",futureTime);
        console.log("timeOffset",timeOffset);
        console.log("currentDownlink",currentDownlink/1000);
        console.log("futureDownlink",futureDownlink/1000);
        console.log("referenceFreq",referenceFreq);
        console.log("maxDeviation",maxDeviation);
        console.log("=======================");
        }*/
        return { referenceFreq, maxDeviation };
    }




        // 判断结果是否为 NaN
    const isDownlinkNaN = isNaN(dopplerShiftDifferencedown);
    const isUplinkNaN = isNaN(dopplerShiftDifferenceup);



    // 构建显示内容
        let dopplerInfo = `<span>          
        <strong>📡 ${description}</strong><br>`;
        dopplerInfo += `Distance ${distancedoppler.toFixed(`1`)} km<br>`;

    if (!isDownlinkNaN) {
        dopplerInfo += `🔻${downlink_low / 1000000} MHz ${directiondown}${dopplerShiftDifferencedown} kHz <br>`;
    }

    if (!isUplinkNaN) {
        dopplerInfo += `🔺${uplink_low / 1000000} MHz ${directionup}${dopplerShiftDifferenceup} kHz<br>`;
    }



    

        if (!isNaN(dopplerShiftDifferencedown) && now >= entryTime && now <= exitTime) {
    const robot36 = calculateSSTVReference(36);
    const robot72 = calculateSSTVReference(72);
    const pd120 = calculateSSTVReference(127);
    const MartinM1 = calculateSSTVReference(114);
// 添加 SSTV 相关信息
    dopplerInfo += `🖼Robot36: ${robot36.referenceFreq} MHz，FDR:${robot36.maxDeviation} kHz<br>`;
    dopplerInfo += `🖼Robot72: ${robot72.referenceFreq} MHz，FDR:${robot72.maxDeviation} kHz<br>`;
    dopplerInfo += `🖼PD120: ${pd120.referenceFreq} MHz，FDR:${pd120.maxDeviation} kHz<br>`;
    dopplerInfo += `🖼MartinM1: ${MartinM1.referenceFreq} MHz，FDR:${MartinM1.maxDeviation} kHz<br>`;
    }

    dopplerInfo += `</span>`;

    // 更新页面内容
    document.getElementById('doppler-info').innerHTML = dopplerInfo;



}
//多普勒功能结束

//pwa
//if ('serviceWorker' in navigator) {
//    navigator.serviceWorker.register('/service-worker.js')
//      .then(registration => {
//        console.log('Service Worker 注册成功:', registration);
 //     })
 //     .catch(error => {
 //       console.log('Service Worker 注册失败:', error);
 //     });
 // }
//pwa
// -------------------------------
/*//【新增功能】计算整个过境期间的多普勒频率并在进度条上显示刻度
function computeDopplerTicks(downlink_low, uplink_low, description) {
  // 从 localStorage 中获取所选过境和卫星数据
  const urlParams = new URLSearchParams(window.location.search);
  const index = urlParams.get('index');
  const satelliteData = JSON.parse(localStorage.getItem('selectedorbit'));
  const selectedPass = satelliteData[index - 1];
  const entryTime = new Date(selectedPass.entryTime);
  const exitTime = new Date(selectedPass.exitTime);

  const satellites = JSON.parse(localStorage.getItem('satellites'));
  const satelliteName = selectedPass.satelliteName;
  const satellited = satellites.find(s => s.name === satelliteName);
  const satelliteTLE1 = satellited.tle[0];
  const satelliteTLE2 = satellited.tle[1];
  const satrec = satellite.twoline2satrec(satelliteTLE1, satelliteTLE2);
  const observerGd = {
    latitude: satellite.degreesToRadians(parseFloat(localStorage.getItem('latitude'))),
    longitude: satellite.degreesToRadians(parseFloat(localStorage.getItem('longitude'))),
    height: parseFloat(localStorage.getItem('altitude')) / 1000
  };

  const progressBarContainer = document.getElementById('progress-bar-container');
  
  // 清除上一次添加的刻度和左侧基准标签（基准标签设置了 id="baseLabel"）
  const oldTicks = progressBarContainer.querySelectorAll('.tick');
  oldTicks.forEach(t => t.remove());
  const existingBaseLabel = progressBarContainer.querySelector('#baseLabel');
  if (existingBaseLabel) {
    existingBaseLabel.remove();
  }

  // 在进度条最左侧显示基准频率（下行和上行分两行）
  const downlinkLow_MHz = (parseFloat(downlink_low) / 1000000).toFixed(3);
  const uplinkLow_MHz = (parseFloat(uplink_low) / 1000000).toFixed(3);
  const baseLabel = document.createElement('div');
  baseLabel.id = 'baseLabel';
  baseLabel.style.position = 'absolute';
  baseLabel.style.left = '0';
  baseLabel.style.top = '10px';
  baseLabel.style.fontSize = '10px';
  baseLabel.style.color = '#000';
  baseLabel.innerHTML = `🔻${downlinkLow_MHz}<br>🔺${uplinkLow_MHz}`;
  progressBarContainer.appendChild(baseLabel);

  const totalDuration = exitTime - entryTime;
  // 定义定点时间 t0 为过境 50% 对应的时刻
  const t0 = new Date(entryTime.getTime() + 0.5 * totalDuration);

  // 固定在指定百分比位置显示刻度
  // 注意：百分比数组中可以包含任意百分比值，本例中包含多个采样点
  const percentages = [20,35, 45,   55, 65,80];

  percentages.forEach(perc => {
    const sampleTime = new Date(entryTime.getTime() + (perc / 100) * totalDuration);
    const positionAndVelocity = satellite.propagate(satrec, sampleTime);
    const gmst = satellite.gstime(sampleTime);
    const positionEci = positionAndVelocity.position;
    const velocityEci = positionAndVelocity.velocity;
    const positionEcf = satellite.eciToEcf(positionEci, gmst);
    const velocityEcf = satellite.eciToEcf(velocityEci, gmst);
    const observerEcf = satellite.geodeticToEcf(observerGd);
    const dopplerFactor = satellite.dopplerFactor(observerEcf, positionEcf, velocityEcf);
    const dopplerShiftDownlink = dopplerFactor * parseFloat(downlink_low);
    const dopplerShiftUplink = dopplerFactor * parseFloat(uplink_low);
    // 计算频偏差（单位 kHz）
    const diffDown = (dopplerShiftDownlink - parseFloat(downlink_low)) / 1000;
    const diffUp = (dopplerShiftUplink - parseFloat(uplink_low)) / 1000;
    
    // 根据过境百分比决定符号和显示的频偏数值
    let signDown, signUp, dispDiffDown, dispDiffUp;
    if (perc < 50) {
      signDown = '+';
      signUp = '+';
      dispDiffDown = Math.abs(diffDown).toFixed(2);
      dispDiffUp = Math.abs(diffUp).toFixed(2);
    } else if (perc > 50) {
      signDown = '-';
      signUp = '-';
      dispDiffDown = Math.abs(diffDown).toFixed(2);
      dispDiffUp = Math.abs(diffUp).toFixed(2);
    } else { // perc == 50
      signDown = '±';
      signUp = '±';
      dispDiffDown = '0';
      dispDiffUp = '0';
    }
    
    // 当计算结果为 NaN 时，不显示相应的内容
    const displayDownStr = (!isNaN(diffDown) && !isNaN(parseFloat(dispDiffDown))) ? `${signDown}${dispDiffDown}` : '';
    const displayUpStr = (!isNaN(diffUp) && !isNaN(parseFloat(dispDiffUp))) ? `${signUp}${dispDiffUp}` : '';

    // 计算相对于定点时间 t0 的秒数差：t0 为零点
    const deltaSec = Math.round((sampleTime.getTime() - t0.getTime()) / 1000);
    // 根据 deltaSec 显示 T-x 或 T+x，当 deltaSec 为负时显示 T-x，正时显示 T+x，零时显示 T+0
    const timeLabel = deltaSec < 0 ? `-${Math.abs(deltaSec)}s` : (deltaSec > 0 ? `+${deltaSec}s` : 'T+0');

    // 创建刻度元素
    const tick = document.createElement('div');
    tick.className = 'tick';
    tick.style.position = 'absolute';
    tick.style.left = perc + '%';
    tick.style.top = '0';
    tick.style.width = '2px';
    tick.style.height = '8px';
    tick.style.backgroundColor = '#000';

    // 创建左侧标签：显示两行频偏信息和相对于 t0 的时间标签
    const leftLabel = document.createElement('div');
    leftLabel.style.position = 'absolute';
    leftLabel.style.top = '10px';
    leftLabel.style.left = (perc - 2) + '%'; // 稍微向左偏移
    leftLabel.style.fontSize = '10px';
    leftLabel.style.color = '#000';
    leftLabel.style.textAlign = 'right';
    leftLabel.innerHTML = `${displayDownStr}<br>${displayUpStr}`;

    tick.appendChild(leftLabel);
    progressBarContainer.appendChild(tick);
  });
}



      // -------------------------------
*/

// Function to display frequency data in the popup
function displayFrequencyData(data, selectedsat) {
    const satelliteInfo = document.getElementById('satellite-feqinfo');


  let content = `<h3>${selectedsat}</h3>`;

      currentLang = localStorage.getItem('lang')

if (currentLang == 'zh') {
  data.forEach(item => { 
    content += `
      <strong>📡${item.description}</strong> 
      <div style="display: flex; justify-content: space-between; align-items: center;">
        <span>🔻 ${formatFrequency(item.downlink_low)}</span>
        <span>🔺 ${formatFrequency(item.uplink_low)}</span>
        <button style="margin-left: 10px;" onclick="startTrackingDoppler('${item.downlink_low}', '${item.uplink_low}', '${item.description}')">多普勒跟踪</button>
      </div>
      <hr>
    `;
  });} else {

  data.forEach(item => { 
    content += `
      <strong>📡${item.description}</strong> 
      <div style="display: flex; justify-content: space-between; align-items: center;">
        <span>🔻 ${formatFrequency(item.downlink_low)}</span>
        <span>🔺 ${formatFrequency(item.uplink_low)}</span>
        <button style="margin-left: 10px;" onclick="startTrackingDoppler('${item.downlink_low}', '${item.uplink_low}', '${item.description}')">Doppler Display</button>
      </div>
      <hr>
    `;
  });

  }

    // Display the content in satelliteInfo
    satelliteInfo.innerHTML = content;
  }

    init();
  </script>

<script>
    window.goatcounter = {
        path: function(p) { return location.host + p }
    }
</script>
<script defer src="https://umami.xanyi.eu.org/script.js" data-website-id="f5178bc6-3761-4415-bcea-469f5cb097d6" data-tag="point"></script>


<div id="made">
Made with ❤ by <a href="https://i.delta.chat/#BD6894FDDEBABE779F08C28215EE6A8466C9F00A&a=troilusxi%40nine.testrun.org&n=troilusxi&i=2YFOSuysc69&s=8to_Foi68Bo" target="_blank" class="link">troilus</a>
</div>

</html>
