<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <!--<link href="/Artalk.css" rel="stylesheet">-->
    <link rel="manifest" href="/manifest.json">
    <title>ğŸ›°ORBIT</title>
    <style>
        :root {
            --primary-color: #007AFF; /* iOS è“è‰² */
            --secondary-color: #F2F2F7; /* iOS æµ…ç°èƒŒæ™¯è‰² */
            --text-color: #000000;
            --hover-color: #0051D5;
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

          /* é»˜è®¤æƒ…å†µä¸‹ï¼Œé“¾æ¥é¢œè‰²ä¸ºé»‘è‰² */
  .link {
    color: #333 ;
    text-decoration: none;
  }

                /* 19:00~07:00 (å¤œé—´) */
        .night {
            background-color: #494953;
            color: #ffffbc;
        }

        /* å…¶ä½™æ—¶é—´ (ç™½å¤©) */
        .day {
            background-color: #2e71d1;
            color: #ffffbc;
        }
        body {
            font-family: var(--font-family);
            background-color: var(--secondary-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            -webkit-font-smoothing: antialiased;
        }

                    #made {
    margin-top: 20px; /* Increases the space above the element */
    font-size: 14px;  /* Optional: Adjust font size */
          text-align: center; /* è®©æ–‡æœ¬å±…ä¸­å¯¹é½ */
}

        #chatIframe {
            width: 100%;
            height: 400px;
            border: 1px solid #ccc;
            display: none; /* é»˜è®¤éšè— iframe */
        }

    .pwa-prompt {
      position: fixed;
      top: 90%;
      right: 10px;
      background-color: #007bff;
      color: #fff;
      padding: 10px 20px;
      border-radius: 5px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      opacity: 1;
      transition: opacity 1s ease-in-out;
      z-index: 1000;
      font-size: 10px;

    }
    .pwa-prompt.hidden {
      opacity: 0;
    }
        .progress-bar-container {
      margin-top: 10px;
      background-color: rgba(255, 255, 255, 0.3);
      border-radius: 3px;
      height: 5px;
      width: 100%;
      overflow: hidden;
    }
    .progress-bar {
      height: 100%;
      background-color: #ffca28;
      width: 100%;
      transition: width 0.1s linear;
    }


        .search-container {
            display: flex;
            align-items: center;
justify-content: center;
            width: 100%;
                        margin-bottom: 10px;
                        gap:5px;
        }

        .config-container {
            display: flex;
            align-items: center;
justify-content: center;
            width: 100%;
                        margin-bottom: 10px;
        }


        h1 {
            margin-bottom: 20px;
        }





                .lang-toggle {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 14px;
        }
        .lang-toggle a {
            margin: 0 5px;
            text-decoration: none;
            color: #919191;
        }
        .lang-toggle a.active {
            font-weight: bold;
            color: black;
        }

        @media (prefers-color-scheme: dark) {
    .lang-toggle a.active {
            font-weight: bold;
            color: white;
    }
}


.elevation-filter {
    display: flex;
    align-items: center; /* å‚ç›´å±…ä¸­å¯¹é½ */
        /* gap: 8px; æ§åˆ¶ label å’Œ select ä¹‹é—´çš„é—´è· */

}

#elevationThresholdLabel {
    margin: 0;
}




.days-filter {
    display: flex;
    align-items: center; /* å‚ç›´å±…ä¸­å¯¹é½ */

}

#daysLabel {
    margin: 0;
}
.button-container {
    display: flex;
    gap: 10px;  /* æŒ‰é’®ä¹‹é—´çš„é—´è· */
}

.button {
    padding: 12px 20px;
    border: none;
    border-radius: 12px;
    background-color: var(--primary-color);
    color: white;
    font-size: 16px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s;
    -webkit-tap-highlight-color: transparent;
    margin-top: 10px;  /* ä¸Šé—´è· */
        margin-bottom: 10px;  /* ä¸Šé—´è· */

}

        .button:active {
            transform: scale(0.98);
            background-color: var(--hover-color);
        }

        .custom-dropdown {
    position: relative;
    width: 85%;
        }

        .custom-dropdown button {
            width: 100%;
            height: 44px;
            text-align: left;
            background-color: white;
            border: none;
            border-radius: 12px;
            padding: 10px 16px;
            font-size: 16px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .dropdown-item {
    padding: 12px 16px;
    border-bottom: 1px solid #E5E5EA;
}

.dropdown-item:last-child {
    border-bottom: none;
}

.dropdown-item:hover {
    background-color: #f0f0f0;
}



        .dropdown-list {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    background-color: white;
    border-radius: 12px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    max-height: 400px;
    overflow-y: auto;
    z-index: 1000;
    display: none; /* é»˜è®¤éšè— */
        }
@media (prefers-color-scheme: dark) {
    .dropdown-list {
        background-color: #1C1C1E; /* æ·±è‰²æ¨¡å¼èƒŒæ™¯ */
        border: 1px solid #555;
    }
}
        .dropdown-list div {
            padding: 10px;
            cursor: pointer;
            font-size: 14px;
        }

        .dropdown-list div:hover {
            background-color: var(--primary-color);
            color: white;
        }

        #searchInput {
            width: 100%;
            height: 44px;
            padding: 12px 16px;
            font-size: 16px;
            border: none;
            border-radius: 12px;
            background-color: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            box-sizing: border-box;
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            margin: 4px;

        }



        #satelliteLinkContainer {
            margin-top: 20px;
            max-width: 300px;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --primary-color: #0A84FF;
                --secondary-color: #2c2c2c;
                --text-color: #FFFFFF;
            }

            body {
                color: var(--text-color);
            }

            .custom-dropdown button, 
            #searchInput, 
         {
                background-color: #1C1C1E;
                border: 1px solid #555;
                color: var(--text-color);



            }

            .dropdown-list div:hover {
                background-color: var(--hover-color);
                color: white;
            }

                .link {
      color: #ddd; /* æˆ–è€…é€‰æ‹©å…¶ä»–åˆé€‚çš„é¢œè‰²ï¼Œå¦‚è“è‰² */
    }



        }
        table {
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        th, td {
            padding-top: 10px;
                        padding-bottom: 10px;
            border: 1px solid #E5E5EA;
        }

        @media (prefers-color-scheme: dark) {
   

        table {
            background: #333;

        }


            .dropdown-item {
                border-bottom-color: #38383A;
            }
        }





    </style>
</head>
<body>
    <div id="location" style="align-self: left;"></div>
    <h1>ğŸŒORBIT</h1>
<!--<script src="/Artalk.js"></script>-->



        <!-- è¯­è¨€åˆ‡æ¢æŒ‰é’® -->
    <div class="lang-toggle">
        <a href="https://hits.sh/sat.xanyi.eu.org/"><img alt="Hits" src="https://hits.sh/sat.xanyi.eu.org.svg?style=plastic"/></a> | <a href="#" id="langZH" class="active">ZH</a> | <a href="#" id="langEN">EN</a> |  <a href="https://github.com/troilus/predict" target="_blank" class="link">CODE</a> |  <a href="https://umami.xanyi.eu.org/share/g3swaIVBuBNOBNuS/sat.xanyi.eu.org" target="_blank" class="link">STATISTICS</a>
    </div>




<div class="search-container">

<div class="custom-dropdown">
    <input type="text" id="searchInput" placeholder="ğŸ”æœç´¢å«æ˜Ÿ..." />
    <div class="dropdown-list" id="satelliteDropdown"></div>

</div>

<button id="starButton" class="star-button" style="display:none; border: none; background: transparent; font-size: 17px; padding: 0; width: auto; height: auto; text-align: center;">
  âšª
</button>
</div>


    <!--<input type="text" id="searchInput" placeholder="æœç´¢å«æ˜Ÿ..." />-->


    <div class="config-container">
                <div class="days-filter">
    <label for="days"  id="daysLabel"></label>
    <select id="days">
        <option value="1">1</option>
        <option value="3" selected>3</option>
        <option value="5" >5</option>
        <option value="10">10</option>
        <option value="15">15</option>

    </select>
</div>

            <div class="elevation-filter">
    <label for="elevationThreshold"  id="elevationThresholdLabel"></label>
    <select id="elevationThreshold">
        <option value="0">0Â°</option>
        <option value="10">10Â°</option>
        <option value="15" selected>15Â°</option>
        <option value="20">20Â°</option>
        <option value="25">25Â°</option>
        <option value="30">30Â°</option>
        <option value="35">35Â°</option>
        <option value="40">40Â°</option>
        <option value="45">45Â°</option>
    </select>
</div>


    <div class="checkbox-container">
        <label for="timeFilter"  id="timeFilterLabel" ></label>
        <input type="checkbox" id="timeFilter">
    </div>









</div>




<div class="button-container">
    <!--<button id="getLocation" class="button">è·å–ä½ç½®</button>-->
        <button id="calculatePassfavorite" class="button">æ˜¾ç¤ºæ”¶è—</button>
    <button id="calculatePass" class="button">æ˜¾ç¤ºé€‰ä¸­</button>

</div>
<div id="notesInfo" style="font-weight: bold; padding-bottom: 10px; font-size: 11px;"></div>
<div id="passInfo" style=" width: 100%; text-align: center;"  ></div>

<!--<button id="sstveventsbutton" >SSTVæ´»åŠ¨</button>
<div id="sstvevents"></div>-->

<!--<button id="toggleButton">åŠ å…¥åœ¨çº¿èŠå¤©</button>
    <iframe id="chatIframe"></iframe>-->
<!--<div id="Comments"></div>-->

<div id="made">
  Made with â¤ by troilus
</div>

<div id="TLEinfo"></div>
<div id="pwaPrompt" class="pwa-prompt hidden"> æ¨èåœ¨ Safari ä¸­ç‚¹å‡»åˆ†äº«æŒ‰é’®ï¼Œé€‰æ‹©â€œæ·»åŠ åˆ°ä¸»å±å¹•â€å®‰è£…ä¸ºåº”ç”¨</div>








    <script src="satellite.js"></script>
        <script src="suncalc.min.js"></script>
          <script src="client.js"></script>

<script src="/require.js"></script>
<script src="/lightstreamer.min.js"></script>

    <script>


                // å®šä¹‰è¯­è¨€å†…å®¹
        const translations = {
            zh: {
                location: "ğŸ“${latitude}, ${longitude} ğŸ—º${locatormg} ğŸ“…æ˜Ÿå†: ${gettleversion}",
                locationDefault: "âŒä½ç½®ä¿¡æ¯: æœªè·å–",
                timeFilterLabel: "ä»…19:00~23:59",
                daysLabel: "å¤©æ•°:",
                elevationThresholdLabel: "æœ€é«˜ä»°è§’â‰¥",
                notesInfo: "â„¹ï¸ç‚¹å‡»ä»°è§’: å®æ—¶å¯¹æ˜Ÿ<br>â°ç‚¹å‡»å¼€å§‹æ—¶é—´: åŠ å…¥æ—¥å†æé†’",
                placeholder: "ğŸ”æœç´¢å«æ˜Ÿ...",
                calculatePass:"æ˜¾ç¤ºé€‰ä¸­",
                                 noTLE:"âš æ— TLEä¿¡æ¯",
                                 unabletocalc:"âš è¯·é€‰æ‹©å«æ˜Ÿå¹¶ç¡®è®¤å·²å®šä½",
                                 chatonline:"åŠ å…¥åœ¨çº¿èŠå¤©",
                                 closeonline:"å…³é—­åœ¨çº¿èŠå¤©",
                                 sstveventsinfo:"SSTVæ´»åŠ¨",

        noPassesInfo: "âš å½“å‰æ¡ä»¶ä¸‹æœªæ¥3å¤©å†…æ²¡æœ‰è¿‡å¢ƒä¿¡æ¯",
        noFavorites: "âš è¿˜æ²¡æœ‰æ”¶è—çš„å«æ˜Ÿ",
                    nolocation:"âš æ— æ³•è·å–ä½ç½®ï¼Œè¯·æ£€æŸ¥æƒé™è®¾ç½®",
        calculating:"ğŸ”é¢„æµ‹ä¸­...",
        tableHeaders: {
            date: "æ—¥æœŸ",
            start: "å¼€å§‹",
            highest: "æœ€é«˜ä»°è§’",
            end: "ç»“æŸ",
            time: "æ—¶é—´",
            azimuth: "æ–¹ä½",
            elevation: "ä»°è§’",

            satellite:"å«æ˜Ÿ"
        }

        },

            en: {
                location: "ğŸ“${latitude}, ğŸ—º${longitude} ${locatormg} ğŸ“…TLE: ${gettleversion}",
                locationDefault: "âŒLocation: Not Retrieved",
                timeFilterLabel: "19:00~23:59 Only",
                elevationThresholdLabel: "MAX. El â‰¥",
                daysLabel: "Days:",
                notesInfo: "â„¹ï¸Click the El to view the orbit page<br>â°Click the Date to add the event to calendar",
                placeholder: "ğŸ”Search satellites...",
                 calculatePass:"Show selected",
                                 noTLE:"âš TLE not found",
                                  unabletocalc:"âš Please select a satellite and confirm that the location has been determined",
                   noPassesInfo: "âš No passes found for the next 3 days under the current conditions",
                           noFavorites: "âš There is no favorite SAT",
                           calculating:"ğŸ”Calculating...",
                                       nolocation:"âš Unable to access location, please check the permission setting",
                                chatonline:"Online Chat",
                                 closeonline:"Close Chat",
                                 sstveventsinfo:"ongoing SSTV events",
        tableHeaders: {
            date: "Date",
            start: "Start",
            highest: "Max. El",
            end: "End",
            time: "Time",
            azimuth: "Az",
            elevation: "El",

                        satellite:"SAT"
        }
        }
        };

        // è®¾ç½®é»˜è®¤è¯­è¨€
        let currentLang = localStorage.getItem('lang') || 'zh';
            /*const sstvbutton = document.getElementById("sstveventsbutton");*/




    const eventsDiv = document.getElementById("sstvevents");

        // æ›´æ–° placeholder å†…å®¹
function updatePlaceholder() {
    const searchInput = document.getElementById('searchInput');
    searchInput.placeholder = translations[currentLang].placeholder;
}


function updateTable() {
    let html = `
        <table border="1" style="border-collapse: collapse; width: 100%; text-align: center;">
            <thead>
                <tr>
                    <th rowspan="2">${translations[currentLang].table.date}</th>
                    <th rowspan="2">${translations[currentLang].table.start}</th>
                    <th colspan="3">${translations[currentLang].table.highestPoint}</th>
                    <th rowspan="2">${translations[currentLang].table.end}</th>
                </tr>
                <tr>
                    <th>${translations[currentLang].table.time}</th>
                    <th>${translations[currentLang].table.azimuth}</th>
                    <th>${translations[currentLang].table.elevation}</th>
                </tr>
            </thead>
            <tbody>
            </tbody>
        </table>
    `;

    document.getElementById('tableContainer').innerHTML = html;
}


function updateTableHeaders(lang) {
    const passInfoDiv = document.getElementById('passInfo');
 const calculated  =  localStorage.getItem('calculated');
    
    // æ£€æŸ¥æ˜¯å¦å­˜åœ¨è¡¨æ ¼
    const table = passInfoDiv.getElementsByTagName('table')[0];
    if (table) {

        if (calculated ==1){
        // å¦‚æœè¡¨æ ¼å­˜åœ¨ï¼Œæ›´æ–°è¡¨å¤´æ–‡æœ¬
        const headers = table.getElementsByTagName('th');
        
        headers[0].textContent = translations[lang].tableHeaders.date;
        headers[1].textContent = translations[lang].tableHeaders.start;
        //headers[2].textContent = translations[lang].tableHeaders.satellite;
        headers[2].textContent = translations[lang].tableHeaders.highest;
        headers[3].textContent = translations[lang].tableHeaders.end;        
        headers[5].textContent = translations[lang].tableHeaders.elevation;
        headers[4].textContent = translations[lang].tableHeaders.time;
} else  if (calculated ==2){
            const headers = table.getElementsByTagName('th');
        headers[0].textContent = translations[lang].tableHeaders.date;
        headers[1].textContent = translations[lang].tableHeaders.start;
        headers[2].textContent = translations[lang].tableHeaders.satellite;
        headers[6].textContent = translations[lang].tableHeaders.elevation;
        headers[3].textContent = translations[lang].tableHeaders.highest;
        headers[4].textContent = translations[lang].tableHeaders.end;        

        headers[5].textContent = translations[lang].tableHeaders.time;

}
    } else {
        // å¦‚æœæ²¡æœ‰è¡¨æ ¼ï¼Œæ›´æ–°æ˜¾ç¤ºçš„æ–‡æœ¬
        passInfoDiv.innerHTML = `<p>${translations[lang].noPassesInfo}</p>`;
    }
}

                // åˆå§‹åŒ–é¡µé¢å†…å®¹
        function updateContent(lang) {



            gettleversion().then(tleversion => {
                const tleversionfix =tleversion;


                                if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(function(position) {
                    const latitude = position.coords.latitude;
                    const longitude = position.coords.longitude;
                    const latitudefix = position.coords.latitude.toFixed(2);
                    const longitudefix = position.coords.longitude.toFixed(2);
                    const altitude = position.coords.altitude;
                    const accuracy = position.coords.accuracy.toFixed(1);

                    localStorage.setItem('latitude', latitude);
                    localStorage.setItem('longitude', longitude);
                    localStorage.setItem('altitude', altitude);
                    const locationText = translations[currentLang].location
                            .replace('${latitude}', latitudefix)
                            .replace('${longitude}', longitudefix)
                            .replace('${gettleversion}', tleversion);
                    document.getElementById('notesInfo').textContent = locationText;
                }, function(error) {
                    document.getElementById('notesInfo').textContent = translations[currentLang].nolocation

                });
            } else {
                document.getElementById('notesInfo').textContent = 'æµè§ˆå™¨ä¸æ”¯æŒåœ°ç†å®šä½ã€‚';
            }

            }).catch(error => {
                console.error("Error fetching TLE version: ", error);
            });




           /*document.getElementById('toggleButton').textContent = translations[currentLang].chatonline*/
            document.getElementById('notesInfo').textContent = translations[lang].location;
            document.getElementById('timeFilterLabel').textContent = translations[lang].timeFilterLabel;
            document.getElementById('daysLabel').textContent = translations[lang].daysLabel;
            document.getElementById('elevationThresholdLabel').textContent = translations[lang].elevationThresholdLabel;
            /*document.getElementById('sstveventsbutton').textContent = translations[lang].sstveventsinfo;*/



            document.getElementById('calculatePass').textContent = translations[lang].calculatePass;
            const notesElement = document.getElementById('notesInfo');
            if (notesElement.innerHTML.trim() !== '') {
                notesElement.innerHTML = translations[currentLang].notesInfo;
            }
            document.getElementById('langZH').classList.toggle('active', lang === 'zh');
            document.getElementById('langEN').classList.toggle('active', lang === 'en');
        }










        // åˆ‡æ¢è¯­è¨€äº‹ä»¶
        document.getElementById('langZH').addEventListener('click', (e) => {
            e.preventDefault();
            currentLang = 'zh';
            updateContent(currentLang);
            updatePlaceholder(); // æ›´æ–° placeholder æ–‡æœ¬
            updateTableHeaders(currentLang);
                                localStorage.setItem('lang', currentLang);
                                        updateFavoriteButtonText()
        });

        document.getElementById('langEN').addEventListener('click', (e) => {
            e.preventDefault();
            currentLang = 'en';
            updateContent(currentLang);
            updatePlaceholder(); // æ›´æ–° placeholder æ–‡æœ¬
            updateTableHeaders(currentLang);
            localStorage.setItem('lang', currentLang);
            updateFavoriteButtonText()

        });

        // åˆå§‹åŒ–é¡µé¢
        updateContent(currentLang);
        updatePlaceholder(); // æ›´æ–° placeholder æ–‡æœ¬
        updateFavoriteButtonText()







        let satellites = [];


        window.addEventListener('load', function() {



            document.getElementById('notesInfo').textContent = translations[currentLang].locationDefault;
            localStorage.removeItem('selectedSatelliteName');
            localStorage.removeItem('calculated');
            localStorage.removeItem('selectedSatelliteTLE1');
            localStorage.removeItem('selectedSatelliteTLE2');
            localStorage.removeItem('selectedorbit');
            localStorage.removeItem('freqinfo');

            fetchTelemetryValueAsync();




            // Get tleversion asynchronously
            gettleversion().then(tleversion => {


          if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(function(position) {
                    const latitude = position.coords.latitude;
                    const longitude = position.coords.longitude;
                    const latitudefix = position.coords.latitude.toFixed(2);
                    const longitudefix = position.coords.longitude.toFixed(2);
                    const altitude = position.coords.altitude || '0';
                    const accuracy = position.coords.accuracy.toFixed(1);
                    localStorage.setItem('latitude', latitude);
                    localStorage.setItem('longitude', longitude);
                    localStorage.setItem('altitude', altitude);








    const locationText = translations[currentLang].location
        .replace('${latitude}', latitudefix)
        .replace('${longitude}', longitudefix)
        .replace('${gettleversion}', tleversion);
        calculateMaidenhead(latitude, longitude,locationText);




    
                }, function(error) {
                    document.getElementById('notesInfo').textContent = 'æ— æ³•è·å–ä½ç½®ï¼Œè¯·æ£€æŸ¥æƒé™è®¾ç½®ã€‚';
                });
            } else {
                document.getElementById('notesInfo').textContent = 'æµè§ˆå™¨ä¸æ”¯æŒåœ°ç†å®šä½ã€‚';
            }



            //fetch('https://c0rs.xanyi.eu.org/?https://r4uab.ru/satonline.txt')
            fetch('/satonline.txt')
                .then(response => {


                    if (!response.ok) {
                        throw new Error('ç½‘ç»œå“åº”å¤±è´¥');
                    }

                    return response.text();
                })
                .then(data => {
                    satellites = parseSatellitesData(data);

                    localStorage.setItem('satellites', JSON.stringify(satellites));
                    populateDropdown(satellites);
                })
                .catch(error => {
                    console.error('æ— æ³•åŠ è½½æ–‡ä»¶:', error);
                });



            }).catch(error => {
                console.error("Error fetching TLE version: ", error);
            });


              
        });

// Function to calculate Maidenhead locator
function calculateMaidenhead(latitude, longitude,locationText) {
    if (latitude < -90 || latitude > 90 || longitude < -180 || longitude > 180) {
        throw new Error("Invalid latitude or longitude values. Latitude must be between -90 and 90, and longitude between -180 and 180.");
    }

    // Adjust longitude to a 0-360 range
    longitude += 180;

    // Calculate the Maidenhead components
    const A = "ABCDEFGHIJKLMNOPQRSTUVWX";

    // First pair: Field (20x10 degrees)
    const fieldLon = Math.floor(longitude / 20);
    const fieldLat = Math.floor((latitude + 90) / 10);

    // Second pair: Square (2x1 degrees)
    const squareLon = Math.floor((longitude % 20) / 2);
    const squareLat = Math.floor((latitude + 90) % 10);

    // Third pair: Subsquare (5x2.5 minutes)
    const subsquareLon = Math.floor(((longitude % 2) * 60) / 5);
    const subsquareLat = Math.floor((((latitude + 90) % 1) * 60) / 2.5);

    // Construct the Maidenhead locator
    const locator = `${A[fieldLon]}${A[fieldLat]}${squareLon}${squareLat}${A[subsquareLon]}${A[subsquareLat]}`;



    const locationText2 = locationText
        .replace('${locatormg}', locator);
    document.getElementById('notesInfo').textContent = locationText2;


    return locator;
}
//        
function gettleversion() {
    return new Promise((resolve, reject) => {
        fetch('/satonline.txt')
            .then(response => {
                if (!response.ok) {
                    throw new Error('ç½‘ç»œå“åº”å¤±è´¥');
                }
                
                const lastModifiedfix = new Date(response.headers.get('Last-Modified'));
                const tleversion = formatDate(lastModifiedfix); // Assuming formatDate is a valid function
                resolve(tleversion); // Resolve the promise with the tleversion
            })
            .catch(error => {
                reject(error); // Reject the promise in case of an error
            });
    });
}

function parseSatellitesData(data) {
            const lines = data.split('\n');
            const satellites = [];
            let currentSatellite = null;

            lines.forEach(line => {
                if (line.startsWith('1') || line.startsWith('2')) {
                    if (currentSatellite) {
                        currentSatellite.tle.push(line);
                    }
                } else if (line.trim() !== '') {
                    if (currentSatellite) {
                        satellites.push(currentSatellite);
                    }
                    currentSatellite = { name: line.trim(), tle: [] };
                }
            });

            if (currentSatellite) {
                satellites.push(currentSatellite);
            }

            return satellites;
        }
//æ”¶è—ç›¸å…³åŠŸèƒ½
function isFavorite(satelliteName) {
    // ä» localStorage è·å– favorites
    const favorites = JSON.parse(localStorage.getItem('favorites') || '{}');

    // åˆ¤æ–­å«æ˜Ÿæ˜¯å¦å­˜åœ¨äº favorites ä¸­
    return favorites.names && favorites.names[satelliteName] !== undefined;
}

function toggleFavorite(satelliteName) {
    // è·å– current favorites æ•°æ®
    const favorites = JSON.parse(localStorage.getItem('favorites') || '{}');



        // åˆå§‹åŒ– favorites.names å¦‚æœå°šæœªå­˜åœ¨
    if (!favorites.names) {
        favorites.names = {};
    }

    const satelliteNames = Object.keys(favorites.names);

    if (satelliteNames.includes(satelliteName)) {
        // å¦‚æœè¯¥å«æ˜Ÿå·²ç»æ˜¯æ”¶è—é¡¹ï¼Œåˆ é™¤å®ƒ
        delete favorites.names[satelliteName]
        starButton.textContent = 'âšª'; // æ¢å¤ä¸ºäº”è§’æ˜Ÿ

    } else {
        // å¦‚æœè¯¥å«æ˜Ÿä¸æ˜¯æ”¶è—é¡¹ï¼ŒåŠ å…¥æ”¶è—
        favorites.names[satelliteName] = ""; 
        starButton.textContent = 'ğŸŸ¡'; // æ”¹ä¸ºæ–¹å—

    }

    // æ›´æ–° localStorage ä¸­çš„ favorites
    localStorage.setItem('favorites', JSON.stringify(favorites));
            updateFavoriteButtonText()
}


function updateFavoriteButtonText() {
    // è¯»å–localStorageä¸­çš„favorites
    const favorites = JSON.parse(localStorage.getItem('favorites')) || {};  // å¦‚æœä¸å­˜åœ¨åˆ™è¿”å›ç©ºå¯¹è±¡

    // ç¡®ä¿favorites.nameså­˜åœ¨ä¸”æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œå¦‚æœæ²¡æœ‰ï¼Œåˆ™åˆå§‹åŒ–ä¸ºç©ºå¯¹è±¡
    const favoriteNames = favorites.names || {};

    // è·å– names å¯¹è±¡ä¸­çš„é”®å¹¶ç»Ÿè®¡æ•°é‡
    const favoriteCount = Object.keys(favoriteNames).length;


    // è·å–æŒ‰é’®å¹¶ä¿®æ”¹æ–‡æœ¬
    const calculatePassfavoriteButton = document.getElementById('calculatePassfavorite');
    if (calculatePassfavoriteButton && currentLang == 'zh') {
        calculatePassfavoriteButton.textContent = `æ˜¾ç¤ºæ”¶è—  *${favoriteCount}`;
    } else if (calculatePassfavoriteButton && currentLang == 'en') {
        calculatePassfavoriteButton.textContent = `Show favorites *${favoriteCount}`;
    }
}







//æ”¶è—ç›¸å…³åŠŸèƒ½ç»“æŸ

function populateDropdown(satellites) {
    const searchInput = document.getElementById('searchInput');
    const dropdown = document.getElementById('satelliteDropdown');

    // åˆå§‹åŒ–ä¸‹æ‹‰èœå•
    function renderDropdown(filteredSatellites) {
        starButton.style.display = 'none';
        dropdown.innerHTML = ''; // æ¸…ç©ºåˆ—è¡¨
        filteredSatellites.forEach(satellite => {
            const div = document.createElement('div');
            div.textContent = satellite.name;
            div.classList.add('dropdown-item');
            div.addEventListener('click', function () {
                searchInput.value = satellite.name; // å°†é€‰æ‹©çš„å€¼å¡«å…¥è¾“å…¥æ¡†
                dropdown.style.display = 'none'; // éšè—ä¸‹æ‹‰èœå•
                    // æ˜¾ç¤ºäº”è§’æ˜ŸæŒ‰é’®
                    starButton.style.display = 'inline-block';


                    // åˆ¤æ–­æ˜¯å¦ä¸ºæ”¶è—ï¼Œå¹¶æ›´æ–°æŒ‰é’®
                    if (isFavorite(satellite.name)) {
                        starButton.textContent = 'ğŸŸ¡'; // å¦‚æœæ˜¯æ”¶è—ï¼Œæ˜¾ç¤ºæ–¹å—
                    } else {
                        starButton.textContent = 'âšª'; // å¦åˆ™æ˜¾ç¤ºäº”è§’æ˜Ÿ
                    }

                // è·å–å¹¶å­˜å‚¨å«æ˜Ÿæ•°æ®
                const noradId = satellite.tle[1].split(' ')[1];
                document.title = 'ğŸ›°'+satellite.name;
                localStorage.setItem('selectedSatelliteName', satellite.name);
                localStorage.setItem('selectedSatelliteTLE1', satellite.tle[0]);
                localStorage.setItem('selectedSatelliteTLE2', satellite.tle[1]);

                    // è®¾ç½®ç‚¹å‡»æŒ‰é’®çš„äº‹ä»¶ï¼Œç‚¹å‡»ååˆ‡æ¢æ”¶è—çŠ¶æ€
                    starButton.onclick = function () {
                        toggleFavorite(satellite.name);
                    };


            });
            dropdown.appendChild(div);
        });
        dropdown.style.display = filteredSatellites.length ? 'block' : 'none';
    }

    // ç›‘å¬æœç´¢è¾“å…¥
    searchInput.addEventListener('input', function () {
        const query = searchInput.value.toLowerCase();
        const filteredSatellites = satellites.filter(satellite =>
            satellite.name.toLowerCase().includes(query)
        );
        renderDropdown(filteredSatellites);
    });


        // ç›‘å¬ç‚¹å‡»æœç´¢æ¡†å±•å¼€ä¸‹æ‹‰èœå•å¹¶é€‰ä¸­æ–‡å­—
    searchInput.addEventListener('click', function () {
        searchInput.select(); // é€‰ä¸­æ‰€æœ‰æ–‡å­—
        renderDropdown(satellites); // å±•å¼€ä¸‹æ‹‰èœå•æ˜¾ç¤ºæ‰€æœ‰é€‰é¡¹
    });

    // åˆå§‹åŒ–æ—¶åŠ è½½æ‰€æœ‰é€‰é¡¹
    renderDropdown(satellites);
}

        document.getElementById('searchInput').addEventListener('input', function() {
            const searchValue = this.value.toLowerCase();
            const dropdown = document.getElementById('satelliteDropdown');
            const options = dropdown.querySelectorAll('div');
            options.forEach(option => {
                const text = option.textContent.toLowerCase();
                if (text.includes(searchValue)) {
                    option.style.display = ''; // Show matching options
                } else {
                    option.style.display = 'none'; // Hide non-matching options
                }
            });
        });

        /*document.getElementById('dropdownButton').addEventListener('click', function() {
            const dropdown = document.getElementById('satelliteDropdown');
            dropdown.style.display = (dropdown.style.display === 'block') ? 'none' : 'block';
        });*/
//è®¡ç®—é€‰ä¸­å«æ˜Ÿ
        document.getElementById('calculatePass').addEventListener('click', function() {
            const satelliteName = localStorage.getItem('selectedSatelliteName')
            document.getElementById('passInfo').innerHTML =translations[currentLang].calculating;




            const locationText = document.getElementById('notesInfo').textContent;

            const confirmloc = localStorage.getItem('latitude');
            const isNumeric = (str) => /[0-9.-]/.test(str);
            const match = isNumeric(confirmloc)

            const timeFilterChecked = document.getElementById('timeFilter').checked;
  

            if (satelliteName && match) {
            const latitude = parseFloat(localStorage.getItem('latitude'));
            const longitude = parseFloat(localStorage.getItem('longitude'));

                const altitude = parseFloat(localStorage.getItem('altitude')) / 1000 || 0; // å¦‚æœ altitude æ˜¯ null/undefinedï¼Œé»˜è®¤è®¾ä¸º 0 ;

                const satellites = JSON.parse(localStorage.getItem('satellites'));
                const satelliteinfo = satellites.find(sat => sat.name === satelliteName);

                if (!satelliteinfo) {
                    document.getElementById('passInfo').innerHTML = translations[currentLang].noTLE;
                    return;
                }

                const satrec = satellite.twoline2satrec(satelliteinfo.tle[0], satelliteinfo.tle[1]);
                           
                const currentTime = new Date();
                const passes = calculatePasses(satrec, latitude, longitude, altitude, currentTime, timeFilterChecked);

                const groupedPasses = groupPasses(passes);
                const savedSatelliteDataToLocalStorage=saveSatelliteDataToLocalStorage(groupedPasses, satelliteName)
                document.getElementById('passInfo').innerHTML = formatGroupedPassesToHTML(groupedPasses);
            } else {
                document.getElementById('passInfo').innerHTML =translations[currentLang].unabletocalc;
            }
        });
//è®¡ç®—å·²æ”¶è—å«æ˜Ÿ
        document.getElementById('calculatePassfavorite').addEventListener('click', function() {


            //const satelliteName = localStorage.getItem('selectedSatelliteName')
            const locationText = document.getElementById('notesInfo').textContent;
            const confirmloc = localStorage.getItem('latitude');
            const isNumeric = (str) => /[0-9.-]/.test(str);
            const match = isNumeric(confirmloc)

            const timeFilterChecked = document.getElementById('timeFilter').checked;

                    // è·å–æ‰€æœ‰å«æ˜Ÿæ•°æ®
        const satellites = JSON.parse(localStorage.getItem('satellites'));
        const favorites = JSON.parse(localStorage.getItem('favorites') || '{}');
        
        if (!favorites.names) {
            document.getElementById('passInfo').innerHTML = translations[currentLang].noFavorites;
            return;
        }



  

            if (match) {
            const latitude = parseFloat(localStorage.getItem('latitude'));
            const longitude = parseFloat(localStorage.getItem('longitude'));
            const altitude = parseFloat(localStorage.getItem('altitude')) /1000 || 0;

    // éå†æ¯ä¸ªæ”¶è—çš„å«æ˜Ÿ
            const allGroupedPasses = [];
            for (const satelliteName in favorites.names) {
                const satelliteinfo = satellites.find(sat => sat.name === satelliteName);

            if (!satelliteinfo) {
                continue;  // å¦‚æœè¯¥å«æ˜Ÿçš„è¯¦ç»†ä¿¡æ¯æ²¡æœ‰æ‰¾åˆ°ï¼Œè·³è¿‡æ­¤å«æ˜Ÿ
            }

        // å­˜å‚¨æ‰€æœ‰æ”¶è—å«æ˜Ÿçš„åˆ†ç»„ passes

                const satrec = satellite.twoline2satrec(satelliteinfo.tle[0], satelliteinfo.tle[1]);
                           
                const currentTime = new Date();
                const passesfavorite = calculatePassesfavorite(satrec, latitude, longitude, altitude, currentTime, timeFilterChecked);

                const groupedPasses = groupPassesfavorite(passesfavorite);


            // å°†å½“å‰å«æ˜Ÿçš„åˆ†ç»„ passes ä¿å­˜åˆ° allGroupedPasses æ•°ç»„
            allGroupedPasses.push({
                satelliteName,
                groupedPasses
            });

            }



                document.getElementById('passInfo').innerHTML = formatGroupedPassesToHTMLfavorite(allGroupedPasses);
             }else {
                document.getElementById('passInfo').innerHTML =translations[currentLang].unabletocalc;
            }
        });
//è®¡ç®—å•ä¸ªé€‰ä¸­å«æ˜Ÿ3å¤©
function calculatePasses(satrec, latitude, longitude, altitude, currentTime, filterNightTime) {
    localStorage.setItem('calculated', '1');
    const passes = [];
    const observerGd = {
        latitude: satellite.degreesToRadians(latitude),
        longitude: satellite.degreesToRadians(longitude),
        height: altitude
    };
    const days = parseFloat(document.getElementById('days').value);
    const endTime = new Date(currentTime.getTime() + days * 24 * 60 * 60 * 1000);
    const timeStep = 1 * 1000; // 1ç§’æ­¥é•¿ï¼ˆå•ä½: æ¯«ç§’ï¼‰

    for (let time = currentTime.getTime() - 60 * 60 * 1000; time <= endTime.getTime(); time += timeStep) {
        const passTime = new Date(time);

        const positionAndVelocity = satellite.propagate(satrec, passTime);
        if (positionAndVelocity && positionAndVelocity.position) {
            const gmst = satellite.gstime(passTime);

            const lookAngles = satellite.ecfToLookAngles(
                observerGd,
                satellite.eciToEcf(positionAndVelocity.position, gmst)
            );

            if (lookAngles) {
                const elevationDegrees = satellite.radiansToDegrees(lookAngles.elevation);

                // ä»°è§’å¤§äº 0 åº¦çš„è®°å½•æ·»åŠ åˆ° passes
                if (elevationDegrees > 0) {
                    const pass = {
                        time: passTime,
                        azimuth: satellite.radiansToDegrees(lookAngles.azimuth),
                        elevation: elevationDegrees,
                    };

                    if (filterNightTime) {
                        const passHour = passTime.getHours();
                        if (passHour < 19 || passHour >= 24) {
                            continue; // è·³è¿‡å¤œé—´èŒƒå›´å¤–çš„è®°å½•
                        }
                    }

                    passes.push(pass);
                }
            }
        }
    }

    return passes;
}
//è®¡ç®—å•ä¸ªé€‰ä¸­å«æ˜Ÿ3å¤©ç»“æŸ

//è®¡ç®—æ”¶è—å«æ˜Ÿå¼€å§‹

function calculatePassesfavorite(satrec, latitude, longitude, altitude, currentTime, filterNightTime) {
    localStorage.setItem('calculated', '2');
    const passes = [];
    const observerGd = {
        latitude: satellite.degreesToRadians(latitude),
        longitude: satellite.degreesToRadians(longitude),
        height: altitude
    };

    const days = parseFloat(document.getElementById('days').value);

    const endTime = new Date(currentTime.getTime() + days * 24 * 60 * 60 * 1000);
    const timeStep = 1 * 1000; // 1ç§’æ­¥é•¿ï¼ˆå•ä½: æ¯«ç§’ï¼‰

    for (let time = currentTime.getTime() - 60 * 60 * 1000; time <= endTime.getTime(); time += timeStep) {
        const passTime = new Date(time);

        const positionAndVelocity = satellite.propagate(satrec, passTime);
        if (positionAndVelocity && positionAndVelocity.position) {
            const gmst = satellite.gstime(passTime);

            const lookAngles = satellite.ecfToLookAngles(
                observerGd,
                satellite.eciToEcf(positionAndVelocity.position, gmst)
            );

            if (lookAngles) {
                const elevationDegrees = satellite.radiansToDegrees(lookAngles.elevation);

                // ä»°è§’å¤§äº 0 åº¦çš„è®°å½•æ·»åŠ åˆ° passes
                if (elevationDegrees > 0) {
                    const pass = {
                        time: passTime,
                        azimuth: satellite.radiansToDegrees(lookAngles.azimuth),
                        elevation: elevationDegrees,
                    };

                    if (filterNightTime) {
                        const passHour = passTime.getHours();
                        if (passHour < 19 || passHour >= 24) {
                            continue; // è·³è¿‡å¤œé—´èŒƒå›´å¤–çš„è®°å½•
                        }
                    }

                    passes.push(pass);
                }
            }
        }
    }

    return passes;
}



//è®¡ç®—æ”¶è—å«æ˜Ÿç»“æŸ

function groupPasses(passes) {
    const groupedPasses = [];
    let currentPass = null;
    let hasAboveThreshold  = false; // æ˜¯å¦å‡ºç°è¿‡ä»°è§’ >= 15 çš„ç‚¹
        const elevationThreshold = parseFloat(document.getElementById('elevationThreshold').value);


    passes.forEach((pass, index) => {
        if (!currentPass) {
            // åˆå§‹åŒ–åˆ†ç»„ï¼Œå½“ä»°è§’ä» 0 åº¦å˜ä¸ºæ­£å€¼æ—¶å¼€å§‹è®°å½•
            if (pass.elevation > 0) {
                currentPass = { entry: pass, highest: pass, exit: pass };
                hasAboveThreshold  = pass.elevation >= elevationThreshold; // æ ‡è®°æ˜¯å¦è¾¾åˆ° 15 åº¦
            }
        } else {
            const timeDifference = (new Date(pass.time) - new Date(currentPass.exit.time)) / 1000;

            if (pass.elevation > 0 && timeDifference <= 600) { 
                // æ›´æ–°å‡ºå£ç‚¹
                currentPass.exit = pass;

                // æ›´æ–°æœ€é«˜ç‚¹
                if (pass.elevation > currentPass.highest.elevation) {
                    currentPass.highest = pass;
                }

                // æ ‡è®°æ˜¯å¦è¾¾åˆ° 15 åº¦
                if (pass.elevation >= elevationThreshold) {
                    hasAboveThreshold  = true;
                }
            } else if (pass.elevation > 0) {
                // ä¿å­˜å½“å‰åˆ†ç»„
                if (hasAboveThreshold ) {
                    groupedPasses.push(currentPass);
                }

                // å¼€å§‹æ–°åˆ†ç»„
                currentPass = { entry: pass, highest: pass, exit: pass };
                hasAboveThreshold = pass.elevation >= elevationThreshold;
            } else {
                // å½“ä»°è§’å›åˆ° 0 åº¦æ—¶ç»“æŸåˆ†ç»„
                if (hasAboveThreshold) {
                    groupedPasses.push(currentPass);
                }
                currentPass = null;
                hasAboveThreshold = false;
            }
        }

        // å¦‚æœæ˜¯æœ€åä¸€ä¸ªç‚¹ï¼Œå¼ºåˆ¶ç»“æŸå½“å‰åˆ†ç»„
        if (index === passes.length - 1 && currentPass && hasAboveThreshold) {
            groupedPasses.push(currentPass);
        }
    });

    return groupedPasses;
}



function groupPassesfavorite(passes) {

    const groupedPasses = [];
    let currentPass = null;
    let hasAboveThreshold  = false; // æ˜¯å¦å‡ºç°è¿‡ä»°è§’ >= 15 çš„ç‚¹
        const elevationThreshold = parseFloat(document.getElementById('elevationThreshold').value);


    passes.forEach((pass, index) => {
        if (!currentPass) {
            // åˆå§‹åŒ–åˆ†ç»„ï¼Œå½“ä»°è§’ä» 0 åº¦å˜ä¸ºæ­£å€¼æ—¶å¼€å§‹è®°å½•
            if (pass.elevation > 0) {
                currentPass = { entry: pass, highest: pass, exit: pass };
                hasAboveThreshold  = pass.elevation >= elevationThreshold; // æ ‡è®°æ˜¯å¦è¾¾åˆ° 15 åº¦
            }
        } else {
            const timeDifference = (new Date(pass.time) - new Date(currentPass.exit.time)) / 1000;

            if (pass.elevation > 0 && timeDifference <= 600) { 
                // æ›´æ–°å‡ºå£ç‚¹
                currentPass.exit = pass;

                // æ›´æ–°æœ€é«˜ç‚¹
                if (pass.elevation > currentPass.highest.elevation) {
                    currentPass.highest = pass;
                }

                // æ ‡è®°æ˜¯å¦è¾¾åˆ° 15 åº¦
                if (pass.elevation >= elevationThreshold) {
                    hasAboveThreshold  = true;
                }
            } else if (pass.elevation > 0) {
                // ä¿å­˜å½“å‰åˆ†ç»„
                if (hasAboveThreshold ) {
                    groupedPasses.push(currentPass);
                }

                // å¼€å§‹æ–°åˆ†ç»„
                currentPass = { entry: pass, highest: pass, exit: pass };
                hasAboveThreshold = pass.elevation >= elevationThreshold;
            } else {
                // å½“ä»°è§’å›åˆ° 0 åº¦æ—¶ç»“æŸåˆ†ç»„
                if (hasAboveThreshold) {
                    groupedPasses.push(currentPass);
                }
                currentPass = null;
                hasAboveThreshold = false;
            }
        }

        // å¦‚æœæ˜¯æœ€åä¸€ä¸ªç‚¹ï¼Œå¼ºåˆ¶ç»“æŸå½“å‰åˆ†ç»„
        if (index === passes.length - 1 && currentPass && hasAboveThreshold) {
            groupedPasses.push(currentPass);

        }
    });

    return groupedPasses;
}

function saveSatelliteDataToLocalStorage(groupedPasses, satelliteName) {
    const satelliteData = groupedPasses.map((pass, index) => {
        return {
            satelliteName: satelliteName,
            entryTime: pass.entry?.time ? new Date(pass.entry.time): "æœªçŸ¥æ—¶é—´",
            entryAzimuth: pass.entry?.azimuth ? pass.entry.azimuth.toFixed(2) : "æœªçŸ¥",
            highestTime: pass.highest?.time ? new Date(pass.highest.time): "æœªçŸ¥æ—¶é—´",
            highestAzimuth: pass.highest?.azimuth ? pass.highest.azimuth.toFixed(2) : "æœªçŸ¥",
            highestElevation: pass.highest?.elevation ? pass.highest.elevation.toFixed(2) : "æœªçŸ¥",
            exitTime: pass.exit?.time ? new Date(pass.exit.time):"æœªçŸ¥æ—¶é—´",
            exitAzimuth: pass.exit?.azimuth ? pass.exit.azimuth.toFixed(2) : "æœªçŸ¥"
        };
    });

    // ä½¿ç”¨å«æ˜Ÿåç§°ä½œä¸ºé”®ï¼Œå°†æ•°æ®å­˜å‚¨åˆ° localStorage
    localStorage.setItem('selectedorbit', JSON.stringify(satelliteData));
}


function savefavoriteSatelliteDataToLocalStorage(allPasses) {
    const satelliteData = allPasses.map((item, index) => {
        const pass = item.pass;

        return {
            satelliteName: item.satelliteName,
            entryTime: pass.entry?.time ? new Date(pass.entry.time) : "æœªçŸ¥æ—¶é—´",
            entryAzimuth: pass.entry?.azimuth ? pass.entry.azimuth.toFixed(2) : "æœªçŸ¥",
            highestTime: pass.highest?.time ? new Date(pass.highest.time) : "æœªçŸ¥æ—¶é—´",
            highestAzimuth: pass.highest?.azimuth ? pass.highest.azimuth.toFixed(2) : "æœªçŸ¥",
            highestElevation: pass.highest?.elevation ? pass.highest.elevation.toFixed(2) : "æœªçŸ¥",
            exitTime: pass.exit?.time ? new Date(pass.exit.time) : "æœªçŸ¥æ—¶é—´",
            exitAzimuth: pass.exit?.azimuth ? pass.exit.azimuth.toFixed(2) : "æœªçŸ¥"
        };
    });

    // ä½¿ç”¨å«æ˜Ÿåç§°ä½œä¸ºé”®ï¼Œå°†æ•°æ®å­˜å‚¨åˆ° localStorage
    localStorage.setItem('selectedorbit', JSON.stringify(satelliteData));
}



//è¾“å‡ºå•ä¸ªå«æ˜Ÿhtml
function formatGroupedPassesToHTML(groupedPasses) {

        let prevEntryDate = "";  // Store the previous entry date for comparison
    let prevRowIndex = -1;   // Store the index of the previous row

    

    const satelliteName = localStorage.getItem('selectedSatelliteName');

    if (groupedPasses.length === 0 ) {
        // Hide the "notesInfo" div on the page
        document.getElementById("notesInfo").style.display = "none";
        
        return `<p>${translations[currentLang].noPassesInfo}</p>`;
    } else {
        // Show the "notesInfo" div again if there are grouped passes
        document.getElementById("notesInfo").style.display = "block";
        
        // Continue with the regular pass formatting
        // Add your logic for formatting passes here, if any
    }

    let html = `
        <table border="1" style="border-collapse: collapse; width: 100%; text-align: center;">
            <thead>
                <tr>
                    <th rowspan="2">${translations[currentLang].tableHeaders.date}</th>
                    <th rowspan="2">${translations[currentLang].tableHeaders.start}</th>
                    <th colspan="2">${translations[currentLang].tableHeaders.highest}</th>
                    <th rowspan="2">${translations[currentLang].tableHeaders.end}</th>
                </tr>
                <tr>
                    <th>${translations[currentLang].tableHeaders.time}</th>
                    <th>${translations[currentLang].tableHeaders.elevation}</th>
                </tr>
            </thead>
            <tbody>
    `;







    groupedPasses.forEach((pass, index) => {
        const entrydate = pass.entry?.time ? new Date(pass.entry.time).toLocaleDateString('zh-CN', { month: '2-digit', day: '2-digit' }) : "æœªçŸ¥æ—¶é—´";
        const entryTime = pass.entry?.time ? new Date(pass.entry.time).toLocaleString('zh-CN', { hour: '2-digit', minute: '2-digit', second: '2-digit' }) : "æœªçŸ¥æ—¶é—´";
        const entryAzimuth = typeof pass.entry?.azimuth === "number" ? `${pass.entry.azimuth.toFixed(2)}Â°` : "æœªçŸ¥";
        
        const entryHour = new Date(pass.entry.time).getHours();


            const now = new Date();
    const isCurrent = pass.entry.time && pass.exit.time && now >= pass.entry.time && now <= pass.exit.time;



        // è·å–å½“åœ°çš„æ—¥å‡ºå’Œæ—¥è½æ—¶é—´
        const latitude = parseFloat(localStorage.getItem('latitude'));
        const longitude = parseFloat(localStorage.getItem('longitude'));
        const sunTimes = SunCalc.getTimes(pass.entry.time, latitude, longitude);
        const sunrise = sunTimes.sunrise;
        const sunset = sunTimes.sunset;

        // åˆ¤æ–­ entryTime æ˜¯å¦åœ¨ç™½å¤©æˆ–å¤œæ™š
        let rowClass = "";
        if (pass.entry.time >= sunrise && pass.entry.time <= sunset) {
            rowClass = "day";  // ç™½å¤©
        } else {
            rowClass = "night";  // å¤œæ™š
        }






        lang=currentLang
        document.getElementById('notesInfo').innerHTML = translations[lang].notesInfo; // æ›´æ–° notesInfo å†…å®¹

        const highestTime = pass.highest?.time ? new Date(pass.highest.time).toLocaleString('zh-CN', { hour: '2-digit', minute: '2-digit', second: '2-digit' }) : "æœªçŸ¥æ—¶é—´";
        const highestAzimuth = typeof pass.highest?.azimuth === "number" ? `${pass.highest.azimuth.toFixed(2)}Â°` : "æœªçŸ¥";
        const highestElevation = typeof pass.highest?.elevation === "number" ? `${pass.highest.elevation.toFixed(2)}Â°` : "æœªçŸ¥";

        const exitTime = pass.exit?.time ? new Date(pass.exit.time).toLocaleString('zh-CN', { hour: '2-digit', minute: '2-digit', second: '2-digit' }) : "æœªçŸ¥æ—¶é—´";
        const exitAzimuth = typeof pass.exit?.azimuth === "number" ? `${pass.exit.azimuth.toFixed(2)}Â°` : "æœªçŸ¥";

        // Generate a placeholder for the canvas
// Generate a placeholder for the SVG
const chartId = `chart-${index}`;
const chartHTML = `<svg id="${chartId}" width="17" height="17"></svg>`;

            // å¦‚æœæ˜¯å½“å‰æ—¶é—´åŒºé—´ï¼Œåˆ™è®¾ç½®ç¬¬ä¸€ä¸ªæ ¼å­çš„èƒŒæ™¯é¢œè‰²ä¸ºç»¿è‰²
    const firstCellStyle = isCurrent ? 'style="background-color: green;"' : '';

//æ—¥å†ç›¸å…³
    const eventTitle = `${satelliteName}  ${highestElevation}`;  // äº‹ä»¶æ ‡é¢˜ä¸ºå«æ˜Ÿåç§°+ä»°è§’
        const eventDate = pass.entry?.time ? new Date(pass.entry.time) : new Date();
        const startTime = eventDate.toLocaleString('zh-CN', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        const endTime = pass.exit?.time ? new Date(pass.exit.time).toLocaleString('zh-CN', { hour: '2-digit', minute: '2-digit', second: '2-digit' }) : startTime;
        // Generate ICS link dynamically for each row
        const icsLink = generateICSLink(eventTitle, eventDate, startTime, endTime);
       // Check if the entrydate is the same as the previous one
        if (entrydate === prevEntryDate) {
            // If the same, merge the cell
            html += `
                <tr class="${rowClass}">
                    <td></td>  <!-- Empty cell for the merged date -->
                    <td>  <a href="javascript:void(0)" onclick="downloadICS('${eventTitle}', '${eventDate.toISOString()}', '${startTime}', '${endTime}')" style="color: #ffffbc;">${entryTime}  </a></td>
                    <td>${highestTime}</td>
<td ${firstCellStyle}>
  <a href="point.html?index=${index + 1}" target="_blank" style="color: #ffffbc; display: flex; align-items: center; justify-content: center;">
    ${highestElevation}
    ${chartHTML}
  </a>
</td>
                    <td>${exitTime}</td>
                </tr>
            `;
        } else {
            // If it's a new entrydate, show the date and store it for future comparison
            html += `
                <tr class="${rowClass}">
                    <td>${entrydate}</td>
                    <td>  <a href="javascript:void(0)" onclick="downloadICS('${eventTitle}', '${eventDate.toISOString()}', '${startTime}', '${endTime}')" style="color: #ffffbc;">${entryTime}  </a></td>
                    <td>${highestTime}</td>
<td ${firstCellStyle}>
  <a href="point.html?index=${index + 1}" target="_blank" style="color: #ffffbc; display: flex; align-items: center; justify-content: center;">
    ${highestElevation}
    ${chartHTML}
  </a>
</td>
                    <td>${exitTime}</td>
                </tr>
            `;
            prevEntryDate = entrydate; // Update the previous entrydate
        }

    });

    html += `
        </tbody>
    </table>
    `;

// Append the HTML to the page
document.getElementById('passInfo').innerHTML = html;

// Now that the table is added, draw the trajectories
setTimeout(() => {
    groupedPasses.forEach((pass, index) => {
        const svgContainer = document.getElementById(`chart-${index}`);
        if (svgContainer) {
            drawTrajectorySVG(svgContainer, pass);
        }
    });
}, 0);

    return html;
}
//è¾“å‡ºå•ä¸ªå«æ˜Ÿhtmlç»“æŸ
//è¾“å‡ºå·²æ”¶è—çš„æ‰€æœ‰å«æ˜Ÿhtml
function formatGroupedPassesToHTMLfavorite(allGroupedPasses) {

    let prevEntryDate = "";  // Store the previous entry date for comparison
    let prevSat = "";  // Store the previous entry date for comparison
    let prevRowIndex = -1;   // Store the index of the previous row

    if (allGroupedPasses.length === 0 ) {
        // Hide the "notesInfo" div on the page

        document.getElementById("notesInfo").style.display = "none";
        
        return `<p>${translations[currentLang].noPassesInfo}</p>`;
    } else {
        // Show the "notesInfo" div again if there are grouped passes
   
        document.getElementById("notesInfo").style.display = "block";
        
        // Continue with the regular pass formatting
        // Add your logic for formatting passes here, if any
    }


    let allPasses = [];
        // Sort allGroupedPasses by the entry time of passes for each satellite



    let html = `
        <table border="1" style="border-collapse: collapse; width: 100%; text-align: center;">
            <thead>
                <tr>

                    <th rowspan="2">${translations[currentLang].tableHeaders.date}</th>
                    <th rowspan="2">${translations[currentLang].tableHeaders.start}</th>
                    <th rowspan="2">${translations[currentLang].tableHeaders.satellite}</th>  <!-- æ–°å¢å«æ˜Ÿåç§°åˆ— -->
                    <th colspan="2">${translations[currentLang].tableHeaders.highest}</th>
                    <th rowspan="2">${translations[currentLang].tableHeaders.end}</th>
                </tr>
                <tr>
                    <th>${translations[currentLang].tableHeaders.time}</th>
                    <th>${translations[currentLang].tableHeaders.elevation}</th>
                </tr>
            </thead>
            <tbody>
    `;

   allGroupedPasses.forEach((satelliteGroup) => {
        const satelliteName = satelliteGroup.satelliteName;  // å½“å‰å«æ˜Ÿåç§°
        const groupedPasses = satelliteGroup.groupedPasses;



                groupedPasses.forEach((pass, index) => {
     
            const sortKey = pass.entry.time;

            allPasses.push({
                satelliteName,
                pass,
                sortKey
            });
        });
    });
        lang=currentLang
document.getElementById('notesInfo').innerHTML = translations[lang].notesInfo; // æ›´æ–° notesInfo å†…å®¹

// æŒ‰ç…§ sortKey å¯¹æ‰€æœ‰ passes è¿›è¡Œæ’åº
allPasses.sort((a, b) => {
    return a.sortKey - b.sortKey;  // é€šè¿‡æ—¶é—´æˆ³è¿›è¡Œæ¯”è¾ƒï¼ŒæŒ‰æ—¶é—´æ’åº
});




const savedSatelliteDataToLocalStorage=savefavoriteSatelliteDataToLocalStorage(allPasses)

    allPasses.forEach((item, index) => {
const satelliteName = item.satelliteName;

// åªå–å‰ 5 ä¸ªå­—ç¬¦ï¼Œå¦‚æœé•¿åº¦è¶…è¿‡ 5 å°±åŠ ä¸Šçœç•¥å·
        const shortenedSatelliteName = satelliteName.replace(/\s+/g, '').slice(0, 5) + (satelliteName.length > 5 ? '...' : '');
        const pass = item.pass;

        const entrydate = pass.entry?.time ? new Date(pass.entry.time).toLocaleDateString('zh-CN', { month: '2-digit', day: '2-digit' }) : "æœªçŸ¥æ—¶é—´";
        const entryTime = pass.entry?.time ? new Date(pass.entry.time).toLocaleString('zh-CN', { hour: '2-digit', minute: '2-digit' }) : "æœªçŸ¥æ—¶é—´";
        
        const now = new Date();
        const isCurrent = pass.entry.time && pass.exit.time && now >= pass.entry.time && now <= pass.exit.time;

        const latitude = parseFloat(localStorage.getItem('latitude'));
        const longitude = parseFloat(localStorage.getItem('longitude'));
        const sunTimes = SunCalc.getTimes(pass.entry.time, latitude, longitude);
        const sunrise = sunTimes.sunrise;
        const sunset = sunTimes.sunset;

        let rowClass = "";
        if (pass.entry.time >= sunrise && pass.entry.time <= sunset) {
            rowClass = "day";  // ç™½å¤©
        } else {
            rowClass = "night";  // å¤œæ™š
        }

        const highestTime = pass.highest?.time ? new Date(pass.highest.time).toLocaleString('zh-CN', { hour: '2-digit', minute: '2-digit', second: '2-digit' }) : "æœªçŸ¥æ—¶é—´";
        const highestElevation = typeof pass.highest?.elevation === "number" ? `${pass.highest.elevation.toFixed(2)}Â°` : "æœªçŸ¥";
        const exitTime = pass.exit?.time ? new Date(pass.exit.time).toLocaleString('zh-CN', { hour: '2-digit', minute: '2-digit'}) : "æœªçŸ¥æ—¶é—´";

        // Generate a placeholder for the SVG
        const chartId = `chart-${index}`;
        const chartHTML = `<svg id="${chartId}" width="17" height="17" ></svg>`;

        const firstCellStyle = isCurrent ? 'style="background-color: green;"' : '';

        const eventTitle = `${satelliteName}  ${highestElevation}`;  // äº‹ä»¶æ ‡é¢˜ä¸ºå«æ˜Ÿåç§°+ä»°è§’
        const eventDate = pass.entry?.time ? new Date(pass.entry.time) : new Date();
        const startTime = eventDate.toLocaleString('zh-CN', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        const endTime = pass.exit?.time ? new Date(pass.exit.time).toLocaleString('zh-CN', { hour: '2-digit', minute: '2-digit', second: '2-digit' }) : startTime;                





    
        if (entrydate === prevEntryDate ) {
            // If the same, merge the cell
        html += `
            <tr class="${rowClass}">
                <td></td>  <!-- Empty cell for the merged date -->
                <td>
                    <a href="javascript:void(0)" onclick="downloadICS('${eventTitle}', '${eventDate.toISOString()}', '${startTime}', '${endTime}')" style="color: #ffffbc;">
                        ${entryTime}
                    </a>
                </td>
                <td style="font-size: 50%; color: #ffffbc; font-weight: bold;">${satelliteName}</td> <!-- è®¾ç½®å­—ä½“å¤§å°ä¸º50% -->
                <td>${highestTime}</td>
                <td ${firstCellStyle}>
  <a href="point.html?index=${index + 1}" target="_blank" style="color: #ffffbc; display: flex; align-items: center; justify-content: center;">
    ${highestElevation}
    ${chartHTML}
  </a>
</td>
                <td>${exitTime}</td>
            </tr>
        `;
        } else {
            // If it's a new entrydate, show the date and store it for future comparison
        html += `
            <tr class="${rowClass}">
                            <td>${entrydate}</td>
                <td>
                    <a href="javascript:void(0)" onclick="downloadICS('${eventTitle}', '${eventDate.toISOString()}', '${startTime}', '${endTime}')" style="color: #ffffbc;">
                        ${entryTime}
                    </a>
                </td>
                <td style="font-size: 50%; color: #ffffbc; font-weight: bold;">${satelliteName}</td> <!-- è®¾ç½®å­—ä½“å¤§å°ä¸º50% -->

                <td>${highestTime}</td>
                <td ${firstCellStyle}>
  <a href="point.html?index=${index + 1}" target="_blank" style="color: #ffffbc; display: flex; align-items: center; justify-content: center;">
    ${highestElevation}
    ${chartHTML}
  </a>
</td>
                <td>${exitTime}</td>
            </tr>
        `;
            prevEntryDate = entrydate; // Update the previous entrydate
            prevSat = satelliteName
        }





    });

    html += `
        </tbody>
    </table>
    `;


    // Append the HTML to the page
    document.getElementById('passInfo').innerHTML = html;



    // Now that the table is added, draw the trajectories
    setTimeout(() => {
        allPasses.forEach((item, index) => {
            const svgContainer = document.getElementById(`chart-${index}`);
            if (svgContainer) {
               

                    drawTrajectorySVG(svgContainer, item.pass);
            }
        });
    }, 0);

    return html;
}



// æ ¼å¼åŒ–æ—¥æœŸä¸º 'YYYY-MM-DD HH:mm' æ ¼å¼
function formatDate(date) {
    //const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');  // æœˆä»½æ˜¯ä»0å¼€å§‹çš„ï¼Œæ‰€ä»¥è¦åŠ 1
    const day = String(date.getDate()).padStart(2, '0');
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    
    return `${month}-${day} ${hours}:${minutes}`;
}



//æ—¥å†ç›¸å…³
function generateICSLink(eventTitle, eventDate, startTime, endTime) {
    const startDateTime = formatDateToICS(eventDate, startTime);
    const endDateTime = formatDateToICS(eventDate, endTime);

    const icsContent = `BEGIN:VCALENDAR
VERSION:2.0
PRODID:-//Your Company//NONSGML v1.0//EN
BEGIN:VEVENT
SUMMARY:${eventTitle}
DTSTART:${startDateTime}
DTEND:${endDateTime}
UID:${generateUID()}
STATUS:CONFIRMED
BEGIN:VALARM
TRIGGER:-PT10M
DESCRIPTION:Reminder
ACTION:DISPLAY
END:VALARM
END:VEVENT
END:VCALENDAR`;

    const blob = new Blob([icsContent], { type: 'text/calendar' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `${eventTitle}.ics`;  // Download the ICS file
    return link.href;
}

function formatDateToICS(date, time) {
    // Create a new Date object based on the provided date
    const dt = new Date(date);

    // Split the provided time into hours and minutes
    const [hour, minute] = time.split(':');
    
    // Set the hours and minutes from the provided time
    dt.setHours(hour, minute);

    // Get the UTC time from the Date object (since it represents local time initially)
    const utcYear = dt.getUTCFullYear();
    const utcMonth = ('0' + (dt.getUTCMonth() + 1)).slice(-2);  // Month is 0-based
    const utcDay = ('0' + dt.getUTCDate()).slice(-2);
    const utcHour = ('0' + dt.getUTCHours()).slice(-2);
    const utcMinute = ('0' + dt.getUTCMinutes()).slice(-2);
    const utcSecond = ('0' + dt.getUTCSeconds()).slice(-2);

    // Return the formatted time in iCalendar format (UTC time with Z at the end)
    const formattedTime = `${utcYear}${utcMonth}${utcDay}T${utcHour}${utcMinute}${utcSecond}Z`;
    return formattedTime;
}

function generateUID() {
    return 'uid-' + Date.now();
}

// The function to trigger ICS download when a row is clicked
function downloadICS(eventTitle, eventDate, startTime, endTime) {
    const icsLink = generateICSLink(eventTitle, eventDate, startTime, endTime);
    const link = document.createElement('a');
    link.href = icsLink;
    link.click();
}

function drawTrajectorySVG(svgContainer, selectedPass, scaleFactor = 0.17) {
    const centerX = 50 * scaleFactor;
    const centerY = 50 * scaleFactor;
    const radius = 40 * scaleFactor; // ç¼©æ”¾åŠå¾„

    // æ ¹æ®ä»°è§’è°ƒæ•´åŠå¾„
    const getRadiusForElevation = (elevation) => {
        return radius * (90 - elevation) / 90; // ä»°è§’æ˜ å°„ä¸ºåŠå¾„æ¯”ä¾‹
    };

    const entryRadius = getRadiusForElevation(0);
    const exitRadius = getRadiusForElevation(0);
    const highestRadius = getRadiusForElevation(selectedPass.highest?.elevation || 0);

    // å°†æ–¹ä½è§’è½¬æ¢ä¸ºç»˜å›¾åæ ‡
    const toCanvasCoords = (azimuth, distance) => {
        const angle = (90 - azimuth) * (Math.PI / 180); // æ—‹è½¬æ–¹ä½è§’ï¼Œ0Â°æŒ‡å‘åŒ—æ–¹
        const x = centerX + distance * Math.cos(angle);
        const y = centerY - distance * Math.sin(angle);
        return { x, y };
    };

    const { x: entryX, y: entryY } = toCanvasCoords(selectedPass.entry?.azimuth, entryRadius);
    const { x: exitX, y: exitY } = toCanvasCoords(selectedPass.exit?.azimuth, exitRadius);
    const { x: highestX, y: highestY } = toCanvasCoords(selectedPass.highest?.azimuth, highestRadius);

    // æ¸…ç©º SVG å®¹å™¨å†…å®¹
    while (svgContainer.firstChild) {
        svgContainer.removeChild(svgContainer.firstChild);
    }

    // ç»˜åˆ¶å¤–éƒ¨åœ†åœˆ
    const outerCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    outerCircle.setAttribute('cx', centerX);
    outerCircle.setAttribute('cy', centerY);
    outerCircle.setAttribute('r', radius);
    outerCircle.setAttribute('stroke', 'white');
    outerCircle.setAttribute('stroke-width', '1');
    outerCircle.setAttribute('fill', 'none');
    svgContainer.appendChild(outerCircle);

    // ç»˜åˆ¶è½¨è¿¹æ›²çº¿
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    const pathData = `M ${entryX},${entryY} Q ${highestX},${highestY} ${exitX},${exitY}`;
    path.setAttribute('d', pathData);
    path.setAttribute('stroke', 'white');
    path.setAttribute('stroke-width', '1');
    path.setAttribute('fill', 'none');
    svgContainer.appendChild(path);
}



document.addEventListener('click', function(event) {
    const searchInput = document.getElementById('searchInput');
    const dropdown = document.getElementById('satelliteDropdown');

    // æ£€æŸ¥ç‚¹å‡»ç›®æ ‡æ˜¯å¦æ˜¯è¾“å…¥æ¡†æˆ–ä¸‹æ‹‰åˆ—è¡¨çš„ä¸€éƒ¨åˆ†
    if (!searchInput.contains(event.target) && !dropdown.contains(event.target)) {
        dropdown.style.display = 'none'; // éšè—ä¸‹æ‹‰èœå•
    }
});

//åˆ¤æ–­ç™½å¤©é»‘å¤œ


/*//èŠå¤©å¼€å§‹
 const toggleButton = document.getElementById('toggleButton');
        const chatIframe = document.getElementById('chatIframe');
        let isChatOpen = false;





        toggleButton.textContent = translations[currentLang].chatonline



        toggleButton.addEventListener('click', () => {
            if (!isChatOpen) {
                // åŠ è½½å¹¶æ˜¾ç¤º iframe
                chatIframe.src = 'chat.html?orbit';
                chatIframe.style.display = 'block';
        toggleButton.textContent = translations[currentLang].closeonline
            } else {
                // éšè—å¹¶æ¸…é™¤ iframe
                chatIframe.style.display = 'none';
                chatIframe.src = '';
        toggleButton.textContent = translations[currentLang].chatonline
            }
            isChatOpen = !isChatOpen;
        });
//èŠå¤©ç»“æŸ*/



//tank
function fetchTelemetryValueAsync() {
    return new Promise((resolve, reject) => {
        require(["LightstreamerClient", "Subscription"], function (LightstreamerClient, Subscription) {
            try {
                var client = new LightstreamerClient("https://push.lightstreamer.com", "ISSLIVE");
                client.connect();

                var sub = new Subscription("MERGE", ["NODE3000005"], ["Value", "TimeStamp"]);
                client.subscribe(sub);

                function formatTelemetryValue(value) {
                    if (!isNaN(parseFloat(value)) && isFinite(value) && value.toString().includes('.')) {
                        return Number(value).toFixed(5);
                    }
                    const madeDiv = document.getElementById("made");
                    madeDiv.innerHTML = `Made with â¤ by troilus <br> ISS ğŸ‘©ğŸ»â€ğŸš€ğŸš½ ${value}%`;


                    return value;
                }

                sub.addListener({
                    onItemUpdate: function (update) {
                        var updatevalue = formatTelemetryValue(update.getValue("Value"));
                        resolve(updatevalue); // ä½¿ç”¨ Promise è¿”å›å€¼
                    }
                });
            } catch (error) {
                reject(error); // æ•è·é”™è¯¯å¹¶è¿”å›
            }
        });
    });
}
//tank


/*//sstvæ´»åŠ¨
// æ·»åŠ ç‚¹å‡»äº‹ä»¶ç›‘å¬å™¨
    sstvbutton.addEventListener("click", function () {
    // ä½¿ç”¨ Fetch API è·å– sstvevents.txt å†…å®¹
        fetch("/sstvevents.txt")
            .then((response) => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.text();
            })
            .then((data) => {
                // å°†æ•°æ®è§£ææˆè¡¨æ ¼æ ¼å¼
                const rows = data.split("\n").filter(row => row.trim() !== "");
                let tableHTML = "<table border='1' style='border-collapse: collapse; width: 100%; font-size: 14px; text-align: center;'>";
                tableHTML += "<tr><th style='text-align: center;'>Name</th><th style='text-align: center;'>Freq(MHz)</th><th style='text-align: center;'>Time(UTC)</th></tr>";

                rows.forEach(row => {
                    const columns = row.split(/\s{2,}/); // æŒ‰å¤šç©ºæ ¼åˆ†å‰²åˆ—
                    if (columns.length === 3) {
                        tableHTML += `<tr><td style='text-align: center;'>${columns[0]}</td><td style='text-align: center;'>${columns[1]}</td><td style='text-align: center;'>${columns[2]}</td></tr>`;
                    }
                });

                tableHTML += "</table>";
                eventsDiv.innerHTML = tableHTML;
            })
            .catch((error) => {
                // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
                eventsDiv.textContent = `Error: ${error.message}`;
                eventsDiv.style.fontSize = "14px"; // è®¾ç½®è¾ƒå°çš„å­—ä½“
            });
    });

//sstvæ´»åŠ¨ç»“æŸ
*/
  /*  //è¯„è®ºåŠŸèƒ½å¼€å§‹
    Artalk.init({
  el:        '#Comments',                       // ç»‘å®šå…ƒç´ çš„ Selector
  pageKey:   '/post/1',                         // å›ºå®šé“¾æ¥
  pageTitle: '',
  emoticons: false,     
  server:    'https://comments.xanyi.eu.org/',  
  site:      'ORBIT',                   
})
//è¯„è®ºåŠŸèƒ½ç»“æŸ*/

//pwa
if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/service-worker.js')
      .then(registration => {
        console.log('Service Worker æ³¨å†ŒæˆåŠŸ:', registration);
      })
      .catch(error => {
        console.log('Service Worker æ³¨å†Œå¤±è´¥:', error);
      });
  }
//pwa
      // æ£€æµ‹æ˜¯å¦å·²ç»æ˜¯ PWA æ¨¡å¼
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    const isPWA = window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone;


      const pwaPrompt = document.getElementById('pwaPrompt');
    if (isIOS && !isPWA) {
      // æ˜¾ç¤ºæç¤º
      pwaPrompt.classList.remove('hidden');
    }
      // 3 ç§’åéšè—æç¤º
      setTimeout(() => {
        pwaPrompt.remove();  // å®Œå…¨ä» DOM ä¸­ç§»é™¤
      }, 5000);

    
    </script>










<script
  defer
  src="/umami.js"
  data-website-id="496abb71-e440-42cf-9b88-4593e8942949"
  data-host-url="https://umami.xanyi.eu.org"
  data-tag="index"
></script>





</body>
</html>