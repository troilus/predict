<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ğŸ›°</title>
    <style>
        :root {
            --primary-color: #4CAF50;
            --secondary-color: #f0f0f0;
            --text-color: #333;
            --hover-color: #45a049;
            --font-family: 'Arial', sans-serif;
        }

                /* 19:00~07:00 (å¤œé—´) */
        .night {
            background-color: #494953;
            color: #ffffbc;
        }

        /* å…¶ä½™æ—¶é—´ (ç™½å¤©) */
        .day {
            background-color: #2e71d1;
            color: #ffffbc;
        }
        body {
            font-family: var(--font-family);
            background-color: var(--secondary-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

                    #made {
    margin-top: 20px; /* Increases the space above the element */
    font-size: 14px;  /* Optional: Adjust font size */
}

        h1 {
            margin-bottom: 20px;
        }


                .lang-toggle {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 14px;
        }
        .lang-toggle a {
            margin: 0 5px;
            text-decoration: none;
            color: #919191;
        }
        .lang-toggle a.active {
            font-weight: bold;
            color: black;
        }

        @media (prefers-color-scheme: dark) {
    .lang-toggle a.active {
            font-weight: bold;
            color: white;
    }
}


.button {
    padding: 8px 15px;
    border: none;
    border-radius: 5px;
    background-color: var(--primary-color);
    color: white;
    font-size: 16px;
    cursor: pointer;
    transition: background-color 0.3s;
    margin-top: 10px;  /* ä¸Šé—´è· */
        margin-bottom: 10px;  /* ä¸Šé—´è· */

}

        .button:hover {
            background-color: var(--hover-color);
        }

        .custom-dropdown {
    position: relative;
    width: 85%;
        }

        .custom-dropdown button {
            width: 100%;
            height: 40px;
            text-align: left;
            background-color: white;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 10px;
            font-size: 14px;
            cursor: pointer;
        }

        .dropdown-item {
    padding: 5px;
    cursor: pointer;
}

.dropdown-item:hover {
    background-color: #f0f0f0;
}



        .dropdown-list {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    background-color: white;
    border: 1px solid #ccc;
    max-height: 400px;
    overflow-y: auto;
    z-index: 1000;
    display: none; /* é»˜è®¤éšè— */
        }
@media (prefers-color-scheme: dark) {
    .dropdown-list {
        background-color: #333; /* æ·±è‰²æ¨¡å¼èƒŒæ™¯ */
        border: 1px solid #555;
    }
}
        .dropdown-list div {
            padding: 10px;
            cursor: pointer;
            font-size: 14px;
        }

        .dropdown-list div:hover {
            background-color: var(--primary-color);
            color: white;
        }

        #searchInput {
            width: 100%;
            /*max-width: 300px;*/
            padding: 10px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 5px;
            margin-bottom: 10px;
            box-sizing: border-box;
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }



        #satelliteLinkContainer {
            margin-top: 20px;
            max-width: 300px;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --primary-color: #3e8e41;
                --secondary-color: #2c2c2c;
                --text-color: #ddd;
                --hover-color: #2e7033;
            }

            body {
                color: var(--text-color);
            }

            .custom-dropdown button, 
            #searchInput, 
            #passInfo {
                background-color: #444;
                border: 1px solid #555;
                color: var(--text-color);
            }

            .dropdown-list div:hover {
                background-color: var(--hover-color);
                color: white;
            }



        }
    </style>
</head>
<body>
    <h1>ğŸ›°</h1>


        <!-- è¯­è¨€åˆ‡æ¢æŒ‰é’® -->
    <div class="lang-toggle">
        <a href="#" id="langZH" class="active">ZH</a> | <a href="#" id="langEN">EN</a>
    </div>


    <!--<button id="getLocation" class="button">è·å–ä½ç½®</button>-->
    

<div class="custom-dropdown">
    <input type="text" id="searchInput" placeholder="æœç´¢å«æ˜Ÿ..." />
    <div class="dropdown-list" id="satelliteDropdown"></div>
</div>

    <!--<input type="text" id="searchInput" placeholder="æœç´¢å«æ˜Ÿ..." />-->

<div id="location" style="align-self: left;"></div>

    <div class="checkbox-container">
        <label for="timeFilter"  id="timeFilterLabel" ></label>
        <input type="checkbox" id="timeFilter">
    </div>

    <div class="elevation-filter">
    <label for="elevationThreshold"  id="elevationThresholdLabel"></label>
    <select id="elevationThreshold">
        <option value="0">0Â°</option>
        <option value="10">10Â°</option>
        <option value="15" selected>15Â°</option>
        <option value="20">20Â°</option>
        <option value="25">25Â°</option>
        <option value="30">30Â°</option>
        <option value="35">35Â°</option>
        <option value="40">40Â°</option>
        <option value="45">45Â°</option>
    </select>
</div>

    <button id="calculatePass" class="button">è®¡ç®—è¿‡å¢ƒä¿¡æ¯</button>
<div id="notesInfo" style="font-weight: bold;"></div>
<div id="passInfo" style="font-weight: bold;"></div>


    <div id="made">Made with â¤ by troilus</div>


    <script src="satellite.js"></script>

    <script>


                // å®šä¹‰è¯­è¨€å†…å®¹
        const translations = {
            zh: {
                location: "ä½ç½®ï¼š${latitude}, ${longitude}",
                locationDefault: "ä½ç½®ä¿¡æ¯ï¼šæœªè·å–",
                timeFilterLabel: "ä»…è®¡ç®— 19:00 ~ 23:59",
                elevationThresholdLabel: "æœ€é«˜ç‚¹ä»°è§’â‰¥",
                notesInfo: "ç‚¹å‡»ä»°è§’ï¼šå¯¹æ˜Ÿ<br>ç‚¹å‡»æ—¥æœŸï¼šåŠ å…¥æ—¥å†æé†’",
                placeholder: "æœç´¢å«æ˜Ÿ...",
                calculatePass:"è®¡ç®—è¿‡å¢ƒä¿¡æ¯",
                                 noTLE:"æ— TLEä¿¡æ¯",
                                 unabletocalc:"è¯·é€‰æ‹©å«æ˜Ÿå¹¶ç¡®è®¤å·²å®šä½",

        noPassesInfo: "å½“å‰æ¡ä»¶ä¸‹æœªæ¥3å¤©å†…æ²¡æœ‰è¿‡å¢ƒä¿¡æ¯",
        tableHeaders: {
            date: "æ—¥æœŸ",
            start: "å¼€å§‹",
            highest: "æœ€é«˜ä»°è§’",
            end: "ç»“æŸ",
            time: "æ—¶é—´",
            azimuth: "æ–¹ä½",
            elevation: "ä»°è§’",
            nolocation:"æ— æ³•è·å–ä½ç½®ï¼Œè¯·æ£€æŸ¥æƒé™è®¾ç½®"
        }

        },

            en: {
                location: "Location: ${latitude}, ${longitude}",
                locationDefault: "Location: Not Retrieved",
                timeFilterLabel: "Calculate Only from 19:00 ~ 23:59",
                elevationThresholdLabel: "MAX. Elevation â‰¥",
                notesInfo: "Click the El to view the orbit page<br>Click the Date to add the event to calendar",
                placeholder: "Search satellites...",
                 calculatePass:"Calculate",
                                 noTLE:"TLE not found",
                                  unabletocalc:"Please select a satellite and confirm that the location has been determined",
                   noPassesInfo: "No passes found for the next 3 days under the current conditions",
        tableHeaders: {
            date: "Date",
            start: "Start",
            highest: "Max. El",
            end: "End",
            time: "Time",
            azimuth: "Az",
            elevation: "El",
            nolocation:"Unable to access location, please check the permission setting"
        }
        }
        };

        // è®¾ç½®é»˜è®¤è¯­è¨€
        let currentLang = 'zh';
        localStorage.setItem('lang', currentLang);

        // æ›´æ–° placeholder å†…å®¹
function updatePlaceholder() {
    const searchInput = document.getElementById('searchInput');
    searchInput.placeholder = translations[currentLang].placeholder;
}


function updateTable() {
    let html = `
        <table border="1" style="border-collapse: collapse; width: 100%; text-align: center;">
            <thead>
                <tr>
                    <th rowspan="2">${translations[currentLang].table.date}</th>
                    <th rowspan="2">${translations[currentLang].table.start}</th>
                    <th colspan="3">${translations[currentLang].table.highestPoint}</th>
                    <th rowspan="2">${translations[currentLang].table.end}</th>
                </tr>
                <tr>
                    <th>${translations[currentLang].table.time}</th>
                    <th>${translations[currentLang].table.azimuth}</th>
                    <th>${translations[currentLang].table.elevation}</th>
                </tr>
            </thead>
            <tbody>
            </tbody>
        </table>
    `;

    document.getElementById('tableContainer').innerHTML = html;
}


function updateTableHeaders(lang) {
    const passInfoDiv = document.getElementById('passInfo');
        const calculated  =  localStorage.getItem('calculated');
    
    // æ£€æŸ¥æ˜¯å¦å­˜åœ¨è¡¨æ ¼
    const table = passInfoDiv.getElementsByTagName('table')[0];
    if (table) {
        // å¦‚æœè¡¨æ ¼å­˜åœ¨ï¼Œæ›´æ–°è¡¨å¤´æ–‡æœ¬
        const headers = table.getElementsByTagName('th');
        
        headers[0].textContent = translations[lang].tableHeaders.date;
        headers[1].textContent = translations[lang].tableHeaders.start;
        headers[2].textContent = translations[lang].tableHeaders.highest;
        headers[3].textContent = translations[lang].tableHeaders.end;
        headers[4].textContent = translations[lang].tableHeaders.time;        
        headers[5].textContent = translations[lang].tableHeaders.azimuth;
        headers[6].textContent = translations[lang].tableHeaders.elevation;

    } else if (calculated == 1) {
        // å¦‚æœæ²¡æœ‰è¡¨æ ¼ï¼Œæ›´æ–°æ˜¾ç¤ºçš„æ–‡æœ¬
        passInfoDiv.innerHTML = `<p>${translations[lang].noPassesInfo}</p>`;
    }
}

                // åˆå§‹åŒ–é¡µé¢å†…å®¹
        function updateContent(lang) {

                                    if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(function(position) {
                    const latitude = position.coords.latitude;
                    const longitude = position.coords.longitude;
                    const latitudefix = position.coords.latitude.toFixed(2);
                    const longitudefix = position.coords.longitude.toFixed(2);
                    const altitude = position.coords.altitude;
                    const accuracy = position.coords.accuracy.toFixed(1);
                    localStorage.setItem('latitude', latitude);
                    localStorage.setItem('longitude', longitude);
                    localStorage.setItem('altitude', altitude);




    const locationText = translations[currentLang].location
        .replace('${latitude}', latitudefix)
        .replace('${longitude}', longitudefix);

    document.getElementById('location').textContent = locationText;
                }, function(error) {
                    document.getElementById('location').textContent = translations[currentLang].nolocation

                });
            } else {
                document.getElementById('location').textContent = 'æµè§ˆå™¨ä¸æ”¯æŒåœ°ç†å®šä½ã€‚';
            }



            document.getElementById('location').textContent = translations[lang].location;
            document.getElementById('timeFilterLabel').textContent = translations[lang].timeFilterLabel;
            document.getElementById('elevationThresholdLabel').textContent = translations[lang].elevationThresholdLabel;

            document.getElementById('calculatePass').textContent = translations[lang].calculatePass;



        const notesElement = document.getElementById('notesInfo');
        if (notesElement.innerHTML.trim() !== '') {
            notesElement.innerHTML = translations[currentLang].notesInfo;
        }





            // æ›´æ–°è¯­è¨€åˆ‡æ¢æŒ‰é’®çš„æ ·å¼
            document.getElementById('langZH').classList.toggle('active', lang === 'zh');
            document.getElementById('langEN').classList.toggle('active', lang === 'en');
        }

        // åˆ‡æ¢è¯­è¨€äº‹ä»¶
        document.getElementById('langZH').addEventListener('click', (e) => {
            e.preventDefault();
            currentLang = 'zh';
            updateContent(currentLang);
            updatePlaceholder(); // æ›´æ–° placeholder æ–‡æœ¬
            updateTableHeaders(currentLang);
                                localStorage.setItem('lang', currentLang);
        });

        document.getElementById('langEN').addEventListener('click', (e) => {
            e.preventDefault();
            currentLang = 'en';
            updateContent(currentLang);
            updatePlaceholder(); // æ›´æ–° placeholder æ–‡æœ¬
            updateTableHeaders(currentLang);
            localStorage.setItem('lang', currentLang);

        });

        // åˆå§‹åŒ–é¡µé¢
        updateContent(currentLang);
        updatePlaceholder(); // æ›´æ–° placeholder æ–‡æœ¬








        let satellites = [];


        window.addEventListener('load', function() {
            document.getElementById('location').textContent = translations[currentLang].locationDefault;
            localStorage.removeItem('selectedSatelliteName');
            localStorage.removeItem('calculated');
            localStorage.removeItem('selectedSatelliteTLE1');
            localStorage.removeItem('selectedSatelliteTLE2');
            localStorage.removeItem('selectedorbit');


                        if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(function(position) {
                    const latitude = position.coords.latitude;
                    const longitude = position.coords.longitude;
                    const latitudefix = position.coords.latitude.toFixed(2);
                    const longitudefix = position.coords.longitude.toFixed(2);
                    const altitude = position.coords.altitude;
                    const accuracy = position.coords.accuracy.toFixed(1);
                    localStorage.setItem('latitude', latitude);
                    localStorage.setItem('longitude', longitude);
                    localStorage.setItem('altitude', altitude);





    const locationText = translations[currentLang].location
        .replace('${latitude}', latitudefix)
        .replace('${longitude}', longitudefix);

    document.getElementById('location').textContent = locationText;
                }, function(error) {
                    document.getElementById('location').textContent = 'æ— æ³•è·å–ä½ç½®ï¼Œè¯·æ£€æŸ¥æƒé™è®¾ç½®ã€‚';
                });
            } else {
                document.getElementById('location').textContent = 'æµè§ˆå™¨ä¸æ”¯æŒåœ°ç†å®šä½ã€‚';
            }




            //fetch('https://c0rs.xanyi.eu.org/?https://r4uab.ru/satonline.txt')
            fetch('/satonline.txt')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('ç½‘ç»œå“åº”å¤±è´¥');
                    }
                    return response.text();
                })
                .then(data => {
                    satellites = parseSatellitesData(data);

                    localStorage.setItem('satellites', JSON.stringify(satellites));
                    populateDropdown(satellites);
                })
                .catch(error => {
                    console.error('æ— æ³•åŠ è½½æ–‡ä»¶:', error);
                });
        });

function parseSatellitesData(data) {
            const lines = data.split('\n');
            const satellites = [];
            let currentSatellite = null;

            lines.forEach(line => {
                if (line.startsWith('1') || line.startsWith('2')) {
                    if (currentSatellite) {
                        currentSatellite.tle.push(line);
                    }
                } else if (line.trim() !== '') {
                    if (currentSatellite) {
                        satellites.push(currentSatellite);
                    }
                    currentSatellite = { name: line.trim(), tle: [] };
                }
            });

            if (currentSatellite) {
                satellites.push(currentSatellite);
            }

            return satellites;
        }

function populateDropdown(satellites) {
    const searchInput = document.getElementById('searchInput');
    const dropdown = document.getElementById('satelliteDropdown');

    // åˆå§‹åŒ–ä¸‹æ‹‰èœå•
    function renderDropdown(filteredSatellites) {
        dropdown.innerHTML = ''; // æ¸…ç©ºåˆ—è¡¨
        filteredSatellites.forEach(satellite => {
            const div = document.createElement('div');
            div.textContent = satellite.name;
            div.classList.add('dropdown-item');
            div.addEventListener('click', function () {
                searchInput.value = satellite.name; // å°†é€‰æ‹©çš„å€¼å¡«å…¥è¾“å…¥æ¡†
                dropdown.style.display = 'none'; // éšè—ä¸‹æ‹‰èœå•

                // è·å–å¹¶å­˜å‚¨å«æ˜Ÿæ•°æ®
                const noradId = satellite.tle[1].split(' ')[1];
                localStorage.setItem('selectedSatelliteName', satellite.name);
                localStorage.setItem('selectedSatelliteTLE1', satellite.tle[0]);
                localStorage.setItem('selectedSatelliteTLE2', satellite.tle[1]);
            });
            dropdown.appendChild(div);
        });
        dropdown.style.display = filteredSatellites.length ? 'block' : 'none';
    }

    // ç›‘å¬æœç´¢è¾“å…¥
    searchInput.addEventListener('input', function () {
        const query = searchInput.value.toLowerCase();
        const filteredSatellites = satellites.filter(satellite =>
            satellite.name.toLowerCase().includes(query)
        );
        renderDropdown(filteredSatellites);
    });


        // ç›‘å¬ç‚¹å‡»æœç´¢æ¡†å±•å¼€ä¸‹æ‹‰èœå•å¹¶é€‰ä¸­æ–‡å­—
    searchInput.addEventListener('click', function () {
        searchInput.select(); // é€‰ä¸­æ‰€æœ‰æ–‡å­—
        renderDropdown(satellites); // å±•å¼€ä¸‹æ‹‰èœå•æ˜¾ç¤ºæ‰€æœ‰é€‰é¡¹
    });

    // åˆå§‹åŒ–æ—¶åŠ è½½æ‰€æœ‰é€‰é¡¹
    renderDropdown(satellites);
}

        document.getElementById('searchInput').addEventListener('input', function() {
            const searchValue = this.value.toLowerCase();
            const dropdown = document.getElementById('satelliteDropdown');
            const options = dropdown.querySelectorAll('div');
            options.forEach(option => {
                const text = option.textContent.toLowerCase();
                if (text.includes(searchValue)) {
                    option.style.display = ''; // Show matching options
                } else {
                    option.style.display = 'none'; // Hide non-matching options
                }
            });
        });

        /*document.getElementById('dropdownButton').addEventListener('click', function() {
            const dropdown = document.getElementById('satelliteDropdown');
            dropdown.style.display = (dropdown.style.display === 'block') ? 'none' : 'block';
        });*/

        document.getElementById('calculatePass').addEventListener('click', function() {
            const satelliteName = localStorage.getItem('selectedSatelliteName')





            const locationText = document.getElementById('location').textContent;
            const match = locationText.match(/(ä½ç½®ï¼š|Location: )([\-0-9.]+), ([\-0-9.]+)/);

            const timeFilterChecked = document.getElementById('timeFilter').checked;
  

            if (satelliteName && match) {
            const latitude = parseFloat(localStorage.getItem('latitude'));
            const longitude = parseFloat(localStorage.getItem('longitude'));

                const altitude = parseFloat(localStorage.getItem('altitude'));

                const satellites = JSON.parse(localStorage.getItem('satellites'));
                const satelliteinfo = satellites.find(sat => sat.name === satelliteName);

                if (!satelliteinfo) {
                    document.getElementById('passInfo').innerHTML = translations[currentLang].noTLE;
                    return;
                }

                const satrec = satellite.twoline2satrec(satelliteinfo.tle[0], satelliteinfo.tle[1]);
                           
                const currentTime = new Date();
                const passes = calculatePasses(satrec, latitude, longitude, altitude, currentTime, timeFilterChecked);

                const groupedPasses = groupPasses(passes);
                const savedSatelliteDataToLocalStorage=saveSatelliteDataToLocalStorage(groupedPasses, satelliteName)
                document.getElementById('passInfo').innerHTML = formatGroupedPassesToHTML(groupedPasses);
            } else {
                document.getElementById('passInfo').innerHTML =translations[currentLang].unabletocalc;
            }
        });

function calculatePasses(satrec, latitude, longitude, altitude, currentTime, filterNightTime) {
    localStorage.setItem('calculated', '1');
    const passes = [];
    const observerGd = {
        latitude: satellite.degreesToRadians(latitude),
        longitude: satellite.degreesToRadians(longitude),
        height: 0
    };

    const endTime = new Date(currentTime.getTime() + 3 * 24 * 60 * 60 * 1000);
    const timeStep = 1 * 1000; // 1ç§’æ­¥é•¿ï¼ˆå•ä½ï¼šæ¯«ç§’ï¼‰

    for (let time = currentTime.getTime() - 60 * 60 * 1000; time <= endTime.getTime(); time += timeStep) {
        const passTime = new Date(time);

        const positionAndVelocity = satellite.propagate(satrec, passTime);
        if (positionAndVelocity && positionAndVelocity.position) {
            const gmst = satellite.gstime(passTime);

            const lookAngles = satellite.ecfToLookAngles(
                observerGd,
                satellite.eciToEcf(positionAndVelocity.position, gmst)
            );

            if (lookAngles) {
                const elevationDegrees = satellite.radiansToDegrees(lookAngles.elevation);

                // ä»°è§’å¤§äº 0 åº¦çš„è®°å½•æ·»åŠ åˆ° passes
                if (elevationDegrees > 0) {
                    const pass = {
                        time: passTime,
                        azimuth: satellite.radiansToDegrees(lookAngles.azimuth),
                        elevation: elevationDegrees,
                    };

                    if (filterNightTime) {
                        const passHour = passTime.getHours();
                        if (passHour < 19 || passHour >= 24) {
                            continue; // è·³è¿‡å¤œé—´èŒƒå›´å¤–çš„è®°å½•
                        }
                    }

                    passes.push(pass);
                }
            }
        }
    }

    return passes;
}

function groupPasses(passes) {
    const groupedPasses = [];
    let currentPass = null;
    let hasAboveThreshold  = false; // æ˜¯å¦å‡ºç°è¿‡ä»°è§’ >= 15 çš„ç‚¹
        const elevationThreshold = parseFloat(document.getElementById('elevationThreshold').value);


    passes.forEach((pass, index) => {
        if (!currentPass) {
            // åˆå§‹åŒ–åˆ†ç»„ï¼Œå½“ä»°è§’ä» 0 åº¦å˜ä¸ºæ­£å€¼æ—¶å¼€å§‹è®°å½•
            if (pass.elevation > 0) {
                currentPass = { entry: pass, highest: pass, exit: pass };
                hasAboveThreshold  = pass.elevation >= elevationThreshold; // æ ‡è®°æ˜¯å¦è¾¾åˆ° 15 åº¦
            }
        } else {
            const timeDifference = (new Date(pass.time) - new Date(currentPass.exit.time)) / 1000;

            if (pass.elevation > 0 && timeDifference <= 600) { 
                // æ›´æ–°å‡ºå£ç‚¹
                currentPass.exit = pass;

                // æ›´æ–°æœ€é«˜ç‚¹
                if (pass.elevation > currentPass.highest.elevation) {
                    currentPass.highest = pass;
                }

                // æ ‡è®°æ˜¯å¦è¾¾åˆ° 15 åº¦
                if (pass.elevation >= elevationThreshold) {
                    hasAboveThreshold  = true;
                }
            } else if (pass.elevation > 0) {
                // ä¿å­˜å½“å‰åˆ†ç»„
                if (hasAboveThreshold ) {
                    groupedPasses.push(currentPass);
                }

                // å¼€å§‹æ–°åˆ†ç»„
                currentPass = { entry: pass, highest: pass, exit: pass };
                hasAboveThreshold = pass.elevation >= elevationThreshold;
            } else {
                // å½“ä»°è§’å›åˆ° 0 åº¦æ—¶ç»“æŸåˆ†ç»„
                if (hasAboveThreshold) {
                    groupedPasses.push(currentPass);
                }
                currentPass = null;
                hasAboveThreshold = false;
            }
        }

        // å¦‚æœæ˜¯æœ€åä¸€ä¸ªç‚¹ï¼Œå¼ºåˆ¶ç»“æŸå½“å‰åˆ†ç»„
        if (index === passes.length - 1 && currentPass && hasAboveThreshold) {
            groupedPasses.push(currentPass);
        }
    });

    return groupedPasses;
}


function saveSatelliteDataToLocalStorage(groupedPasses, satelliteName) {

    const satelliteData = groupedPasses.map((pass, index) => {
        return {
            satelliteName: satelliteName,
            entryTime: pass.entry?.time ? new Date(pass.entry.time): "æœªçŸ¥æ—¶é—´",
            entryAzimuth: pass.entry?.azimuth ? pass.entry.azimuth.toFixed(2) : "æœªçŸ¥",
            highestTime: pass.highest?.time ? new Date(pass.highest.time): "æœªçŸ¥æ—¶é—´",
            highestAzimuth: pass.highest?.azimuth ? pass.highest.azimuth.toFixed(2) : "æœªçŸ¥",
            highestElevation: pass.highest?.elevation ? pass.highest.elevation.toFixed(2) : "æœªçŸ¥",
            exitTime: pass.exit?.time ? new Date(pass.exit.time):"æœªçŸ¥æ—¶é—´",
            exitAzimuth: pass.exit?.azimuth ? pass.exit.azimuth.toFixed(2) : "æœªçŸ¥"
        };
    });

    // ä½¿ç”¨å«æ˜Ÿåç§°ä½œä¸ºé”®ï¼Œå°†æ•°æ®å­˜å‚¨åˆ° localStorage
    localStorage.setItem('selectedorbit', JSON.stringify(satelliteData));
}






function formatGroupedPassesToHTML(groupedPasses) {

    const satelliteName = localStorage.getItem('selectedSatelliteName');

    if (groupedPasses.length === 0 ) {
        // Hide the "notesInfo" div on the page
        document.getElementById("notesInfo").style.display = "none";
        
        return `<p>${translations[currentLang].noPassesInfo}</p>`;
    } else {
        // Show the "notesInfo" div again if there are grouped passes
        document.getElementById("notesInfo").style.display = "block";
        
        // Continue with the regular pass formatting
        // Add your logic for formatting passes here, if any
    }

    let html = `
        <table border="1" style="border-collapse: collapse; width: 100%; text-align: center;">
            <thead>
                <tr>
                    <th rowspan="2">${translations[currentLang].tableHeaders.date}</th>
                    <th rowspan="2">${translations[currentLang].tableHeaders.start}</th>
                    <th colspan="3">${translations[currentLang].tableHeaders.highest}</th>
                    <th rowspan="2">${translations[currentLang].tableHeaders.end}</th>
                </tr>
                <tr>
                    <th>${translations[currentLang].tableHeaders.time}</th>
                    <th>${translations[currentLang].tableHeaders.azimuth}</th>
                    <th>${translations[currentLang].tableHeaders.elevation}</th>
                </tr>
            </thead>
            <tbody>
    `;

    groupedPasses.forEach((pass, index) => {
        const entrydate = pass.entry?.time ? new Date(pass.entry.time).toLocaleDateString('zh-CN', { month: '2-digit', day: '2-digit' }) : "æœªçŸ¥æ—¶é—´";
        const entryTime = pass.entry?.time ? new Date(pass.entry.time).toLocaleString('zh-CN', { hour: '2-digit', minute: '2-digit', second: '2-digit' }) : "æœªçŸ¥æ—¶é—´";
        const entryAzimuth = typeof pass.entry?.azimuth === "number" ? `${pass.entry.azimuth.toFixed(2)}Â°` : "æœªçŸ¥";
        
        const entryHour = new Date(pass.entry.time).getHours();


            const now = new Date();
    const isCurrent = pass.entry.time && pass.exit.time && now >= pass.entry.time && now <= pass.exit.time;
        let rowClass = "";
        if (entryHour >= 19 || entryHour < 7) {
            rowClass = "night";  // 19:00-07:00ï¼Œç°åº•ç™½å­—
        } else {
            rowClass = "day";    // å…¶ä½™æ—¶é—´ï¼Œè“åº•é»„å­—
        }
        lang=currentLang
        document.getElementById('notesInfo').innerHTML = translations[lang].notesInfo; // æ›´æ–° notesInfo å†…å®¹

        const highestTime = pass.highest?.time ? new Date(pass.highest.time).toLocaleString('zh-CN', { hour: '2-digit', minute: '2-digit', second: '2-digit' }) : "æœªçŸ¥æ—¶é—´";
        const highestAzimuth = typeof pass.highest?.azimuth === "number" ? `${pass.highest.azimuth.toFixed(2)}Â°` : "æœªçŸ¥";
        const highestElevation = typeof pass.highest?.elevation === "number" ? `${pass.highest.elevation.toFixed(2)}Â°` : "æœªçŸ¥";

        const exitTime = pass.exit?.time ? new Date(pass.exit.time).toLocaleString('zh-CN', { hour: '2-digit', minute: '2-digit', second: '2-digit' }) : "æœªçŸ¥æ—¶é—´";
        const exitAzimuth = typeof pass.exit?.azimuth === "number" ? `${pass.exit.azimuth.toFixed(2)}Â°` : "æœªçŸ¥";

        // Generate a placeholder for the canvas
        const chartId = `chart-${index}`;
        const chartHTML = `<canvas id="${chartId}" width="17" height="17"></canvas>`;

            // å¦‚æœæ˜¯å½“å‰æ—¶é—´åŒºé—´ï¼Œåˆ™è®¾ç½®ç¬¬ä¸€ä¸ªæ ¼å­çš„èƒŒæ™¯é¢œè‰²ä¸ºç»¿è‰²
    const firstCellStyle = isCurrent ? 'style="background-color: green;"' : '';

//æ—¥å†ç›¸å…³
    const eventTitle = `${satelliteName}  ${highestElevation}`;  // äº‹ä»¶æ ‡é¢˜ä¸ºå«æ˜Ÿåç§°+ä»°è§’
        const eventDate = pass.entry?.time ? new Date(pass.entry.time) : new Date();
        const startTime = eventDate.toLocaleString('zh-CN', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        const endTime = pass.exit?.time ? new Date(pass.exit.time).toLocaleString('zh-CN', { hour: '2-digit', minute: '2-digit', second: '2-digit' }) : startTime;
        // Generate ICS link dynamically for each row
        const icsLink = generateICSLink(eventTitle, eventDate, startTime, endTime);
        console.log(icsLink)


        html += `
            <tr class="${rowClass}">
                 <td>
  <a href="javascript:void(0)" onclick="downloadICS('${eventTitle}', '${eventDate.toISOString()}', '${startTime}', '${endTime}')" style="color: #ffffbc;">
    ${entrydate}
  </a>
</td>
                <td>${entryTime}, ${entryAzimuth}</td>
                <td>${highestTime}</td>
                <td>${highestAzimuth}</td>
                                <td ${firstCellStyle}><a href="point.html?index=${index + 1}" target="_blank" style="color: #ffffbc;">${highestElevation}${chartHTML}</a></td>
                <td>${exitTime}, ${exitAzimuth}</td>
            </tr>
        `;
    });

    html += `
        </tbody>
    </table>
    `;

    // Append the HTML to the page
    document.getElementById('passInfo').innerHTML = html;

    // Now that the table is added, draw the trajectories
    setTimeout(() => {
        groupedPasses.forEach((pass, index) => {
            const canvas = document.getElementById(`chart-${index}`);
            if (canvas) {
                const ctx = canvas.getContext('2d');
                if (ctx) {
                    drawTrajectory(ctx, pass);
                }
            }
        });
    }, 0);

    return html;
}
//æ—¥å†ç›¸å…³
function generateICSLink(eventTitle, eventDate, startTime, endTime) {
    const startDateTime = formatDateToICS(eventDate, startTime);
    const endDateTime = formatDateToICS(eventDate, endTime);
    console.log(startTime,startDateTime)

    const icsContent = `BEGIN:VCALENDAR
VERSION:2.0
PRODID:-//Your Company//NONSGML v1.0//EN
BEGIN:VEVENT
SUMMARY:${eventTitle}
DTSTART:${startDateTime}
DTEND:${endDateTime}
UID:${generateUID()}
STATUS:CONFIRMED
BEGIN:VALARM
TRIGGER:-PT10M
DESCRIPTION:Reminder
ACTION:DISPLAY
END:VALARM
END:VEVENT
END:VCALENDAR`;

    const blob = new Blob([icsContent], { type: 'text/calendar' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `${eventTitle}.ics`;  // Download the ICS file
    return link.href;
}

function formatDateToICS(date, time) {
    // Create a new Date object based on the provided date
    const dt = new Date(date);

    // Split the provided time into hours and minutes
    const [hour, minute] = time.split(':');
    
    // Set the hours and minutes from the provided time
    dt.setHours(hour, minute);

    // Get the UTC time from the Date object (since it represents local time initially)
    const utcYear = dt.getUTCFullYear();
    const utcMonth = ('0' + (dt.getUTCMonth() + 1)).slice(-2);  // Month is 0-based
    const utcDay = ('0' + dt.getUTCDate()).slice(-2);
    const utcHour = ('0' + dt.getUTCHours()).slice(-2);
    const utcMinute = ('0' + dt.getUTCMinutes()).slice(-2);
    const utcSecond = ('0' + dt.getUTCSeconds()).slice(-2);

    // Return the formatted time in iCalendar format (UTC time with Z at the end)
    const formattedTime = `${utcYear}${utcMonth}${utcDay}T${utcHour}${utcMinute}${utcSecond}Z`;
    return formattedTime;
}

function generateUID() {
    return 'uid-' + Date.now();
}

// The function to trigger ICS download when a row is clicked
function downloadICS(eventTitle, eventDate, startTime, endTime) {
    const icsLink = generateICSLink(eventTitle, eventDate, startTime, endTime);
    const link = document.createElement('a');
    link.href = icsLink;
    link.click();
}

//æ—¥å†ç›¸å…³ç»“æŸ
function drawTrajectory(ctx, selectedPass, scaleFactor = 0.17) { 
    const centerX = 50 * scaleFactor;
    const centerY = 50 * scaleFactor;
    const radius = 40 * scaleFactor;  // ç¼©æ”¾åŠå¾„

    // æ ¹æ®ä»°è§’è°ƒæ•´åŠå¾„
    const getRadiusForElevation = (elevation) => {
        return radius * (90 - elevation) / 90; // ä»°è§’æ˜ å°„ä¸ºåŠå¾„æ¯”ä¾‹
    };

    const entryRadius = getRadiusForElevation(0);
    const exitRadius = getRadiusForElevation(0);
    const highestRadius = getRadiusForElevation(selectedPass.highest?.elevation || 0);

    // å°†æ–¹ä½è§’è½¬æ¢ä¸ºç»˜å›¾åæ ‡
    const toCanvasCoords = (azimuth, distance) => {
        const angle = (90 - azimuth) * (Math.PI / 180); // æ—‹è½¬æ–¹ä½è§’ï¼Œ0Â°æŒ‡å‘åŒ—æ–¹
        const x = centerX + distance * Math.cos(angle);
        const y = centerY - distance * Math.sin(angle);
        return { x, y };
    };

    const { x: entryX, y: entryY } = toCanvasCoords(selectedPass.entry?.azimuth, entryRadius);
    const { x: exitX, y: exitY } = toCanvasCoords(selectedPass.exit?.azimuth, exitRadius);
    const { x: highestX, y: highestY } = toCanvasCoords(selectedPass.highest?.azimuth, highestRadius);

        // Draw black circle around the trajectory
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);  // Outer circle
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 1;
    ctx.stroke();



    // ç»˜åˆ¶è´å¡å°”æ›²çº¿è¿æ¥è½¨è¿¹ç‚¹
    ctx.beginPath();
    ctx.moveTo(entryX, entryY);
    ctx.quadraticCurveTo(highestX, highestY, exitX, exitY);
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 1;
    ctx.stroke();
}


document.addEventListener('click', function(event) {
    const searchInput = document.getElementById('searchInput');
    const dropdown = document.getElementById('satelliteDropdown');

    // æ£€æŸ¥ç‚¹å‡»ç›®æ ‡æ˜¯å¦æ˜¯è¾“å…¥æ¡†æˆ–ä¸‹æ‹‰åˆ—è¡¨çš„ä¸€éƒ¨åˆ†
    if (!searchInput.contains(event.target) && !dropdown.contains(event.target)) {
        dropdown.style.display = 'none'; // éšè—ä¸‹æ‹‰èœå•
    }
});



    </script>

    <script async src="https://umami.xanyi.eu.org/script.js" data-website-id="496abb71-e440-42cf-9b88-4593e8942949"></script>
</body>
</html>
